<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript取出”陣列-物件“重複/不重複值的方法]]></title>
    <url>%2F2018%2F04%2FJavaScript-Duplicates-Array-Object%2F</url>
    <content type="text"><![CDATA[昨天在 FB 社團看到有人提問：123456let arr = [ &#123; name: "alex", value: 10 &#125;, &#123; name: "alex", value: 20 &#125;, &#123; name: "tom", value: 30 &#125;, &#123; name: "tom", value: 40 &#125;]; 想變成1234let arr = [ &#123; name: "alex", value: 10 &#125;, &#123; name: "tom", value: 30 &#125; ]; 想了一陣子想到用Set&amp;Filter來處理.. 去除某物件屬性重複值針對題目的需求是只要重複name的第一筆資料，透過Set來達到去重複的功能並透過filter來獲取結果陣列：12345678910const arr = [ &#123;name:'alex',value:10&#125;, &#123;name:'alex',value:20&#125;, &#123;name:'tom',value:30&#125;, &#123;name:'tom',value:40&#125;];const set = new Set();const result = arr.filter(item =&gt; !set.has(item.name) ? set.add(item.name) : false);console.log(result); // [&#123;name: "alex", value: 10&#125;, &#123;name: "tom", value: 30&#125;] 第一步先建立一個set來當篩選的容器，在filter裡頭判斷，如果set裡面沒有循環到的name,就新增進去，再新增的同時因為filter的特性是會把retun true的內容回傳為新的陣列，箭頭函示不加大括號的情況下會等同於return，在這個情境下等於回傳了一個動作(此動作是成立的，是true)。 去除重複的物件如果要針對整個陣列物件中去除重複物件的話可以透過JSON.stringify來做：123456789const arr = [ &#123;name:'a', value:10&#125;, &#123;name:'a', value:20&#125;, &#123;name:'a', value:20&#125;, &#123;name:'b', value:30&#125;,];const result = [...new Set(arr.map(item =&gt; JSON.stringify(item)))].map(item =&gt; JSON.parse(item));console.log(result); // [&#123;name: "a", value: 10&#125;, &#123;name: "a", value: 20&#125;, &#123;name: "b", value: 30&#125;] 弄成一行看起來好像比較厲害(?)XD 因為物件跟物件之間無法比較，所以想法是透過轉字串來比較，第一步先使用new Set並透過map＆JSON.stringify把每一個陣列內的物件轉為字串，再透過展開運算符[...]來把剛才Set的結果轉為陣列，最後再用一次map把裡面的物件字串透過JSON.parse再轉回物件。 取得重複的物件剛才都是去除重複，那如果是要抓出重複的物件有哪些呢？把邏輯反轉過來：12345678910111213const arr = [ &#123;name:'a', value:10&#125;, &#123;name:'a', value:20&#125;, &#123;name:'a', value:20&#125;, &#123;name:'b', value:30&#125;, &#123;name:'b', value:40&#125;, &#123;name:'b', value:40&#125;];const set = new Set();const result = arr.filter(item =&gt; set.has(JSON.stringify(item)) ? true : (set.add(JSON.stringify(item)), false));console.log(result); //[&#123;name: "a", value: 20&#125;, &#123;name: "b", value: 40&#125;] 這裡跟前面的差不多道理，比較特別在三元運算子的部分，同前面提到的，filter的特性是會將return true的內容加入，所以如果單純寫1set.has(JSON.stringify(item)) ? true : set.add(JSON.stringify(item)) 這樣的話也會被新增進去，因為set.add(JSON.stringify(item))也是個true的動作，所以使用(set.add(JSON.stringify(item)), false)來讓新增動作執行後，再回傳false阻止filter的新增。 其實寫清楚一點就是下面這樣，不過就是會想試試一行寫完的方法ＸＤ1234567const result = arr.filter(item =&gt; &#123; if (set.has(JSON.stringify(item))) &#123; return true; &#125; else &#123; set.add(JSON.stringify(item)); &#125;&#125;); 其他以上都是自己邊試邊理解的，如果有錯誤或更好的寫法也請再告知：Ｄ！ 陣列的做法紀錄JavaScript取出陣列重複/不重複值的方法]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[實用小技巧-複製開發者工具取得的資訊]]></title>
    <url>%2F2018%2F03%2Fdevtool-copy-console-data%2F</url>
    <content type="text"><![CDATA[有時候從API或console印出的陣列或物件資料想存在local使用，在chrome的開發者工具對想要儲存的對象按右鍵store as global variable，在用copy()指令傳入剛才被儲存的變數，想存的物件就被完整複製到剪貼簿啦！ 之前一直沒發現到，查了才知道有這個技巧，有時還要蠢蠢的手動複製一份XD。 參閱：Stackoverflow]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>DevTool</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017的回顧跟2018的目標]]></title>
    <url>%2F2018%2F02%2F2017-review-and-2018-target%2F</url>
    <content type="text"><![CDATA[想到什麼寫什麼，有點亂七八糟的紀錄。 去年一整年是個很充實很緊繃的一年2017的年度目標： 每兩個月一定要寫篇程式相關的心得 每半年要看完一本書並記錄心得第一點大完成，去年整年寫了49篇紀錄，第二點則是失敗，看跟買的書不少，但大部分都開卷即睡..只有掃過目錄跟前面幾章，線上課程完成的比較多，可以倍數跟直接看操作對我來說吸收比較快。 因為自己很想寫前端，但工作上沒什麼機會碰到前端，去年一整年就很緊實的利用下班跟假日的時間一直在讀書，大概在四月底的時候幸運的加入了JS的Line群，在唸書的過程中感覺比較不孤單，也從群內討論中吸收了不少知識，累積了一些作品跟實作的經驗，還接觸了虛擬貨幣！ 每天下班回家接小孩買晚餐吃，小孩弄睡就九點多了，抓緊時間看個線上課程，邊實作寫下紀錄的日子也過了一年，也很幸運的在年前也找到了前端開發的工作，達成自己這段時間努力的目標，正式的成為前端工程師了！ 2019的目標是最少一個月要寫一篇程式相關的紀錄，新的一年一樣希望自己持續成長，持續累積實務經驗，希望一切都很順利，家人身體健康：）！ -#終於可以放鬆些了-#買了NS都沒時間玩，不知道今年有沒有時間把薩爾達破關XD]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Vue.js 製作幸運大轉盤～]]></title>
    <url>%2F2018%2F01%2Fvue-turntable%2F</url>
    <content type="text"><![CDATA[來用vue.js寫一個前端大轉盤吧! 01/19 更新整體編輯模式 DEMO ＆ Source CodeDEMO原始碼-GitHub功能1. 區塊設定設定每個區塊的資料，機率可以隨意數字最後會加總去算成百分比，單塊設定可拖曳編輯(使用Vue.Draggable製作的拖曳功能)。 2. 轉盤設定手動模式：就是單純下個paused把動畫停下來，自動模式：可以設定回彈角度(轉盤動畫結束前的位置反彈) 3. 設定檔可以將不同的區塊＆轉盤設定存檔，因應各種場景切換 TODO有機會有時間想在套個firebase儲存設定資訊，練習登入功能且可以讓朋友作設定分享出去轉～ 紀錄CSS的變數與JS的setProperty覺得很有趣的應用是用了css的變數與js的setProperty，兩個作搭配改變keyframe，藉此來控制每一次隨機的旋轉結束角度，還利用了animition的cubic-bezier作轉盤回彈效果。 Canvas的作圖這次很有趣的是製作過程中學到了弧度的算法(?)在查詢製作範例與教學的過程中又多熟練了一次Canvas的作圖..但真的複雜的要算座標還有各種數學真的好難QQ 越來越複雜原本主體就是Methods裡面的drawCanvas，有計算角度的是autoTurnStart/autoTurnStop這兩個，畫好轉盤後，作角度計算及改變css變數來旋轉。 原本是很單純的，但因為想到很多可設定選項，就把原先很多固定寫的值抽到data去設定，然後尺寸全部改抓比例去動態改，使用統一尺寸作全尺寸的調整，然後就越寫越複雜了囧，但也因此又多練習了幾次應用。 起因這個小作品的起因是公司單位自己辦的尾牙要玩抽獎活動，為了節省經費與人力來換增加金額(?)捨棄物理實體轉盤的製作，一開始同事使用powerpoint畫了張餅圖，用內建動畫來轉，但因為powerpoint的內建動畫轉速不夠快，且是可以被精準預測位置的，我就想說欸，那不然我來寫一個轉盤好了，結果一寫就是一個禮拜的下班時間跟一整個週末XD 第一版思考+製作大概30min，用圖片來轉，想法很單純就是用rotate來轉，使用setInterval/clearInterver來控制增加角度的function，完成之後突然想到，如果要增修獎項，不就要重新出圖嗎?那就捨棄用圖片的方式，把他寫成可設定的轉盤好了，於是有了第二版。 第二版使用ul+li做轉盤的內容，每片扇形都是用rotate+skew來取得，因為數學不好的關係，在算角度時頭很痛XD，然後發現這種扇形組合法角度超過90時就要合併處理，但一合併就有框線與內文的在排版問題(合併的扇形只要左右出框線，文字要在合併角度的中間)，雖然這次活動獎項不會有超過25%(90度)的機會，但我還是想把他做好到可以用在各種情形(搞自己)，燒腦了一天決定放棄用li的方式來組合，改用canvas來做，在旋轉的動畫方面則在嘗試中試出了用Keyframe + css varable來做的方法(突然覺得自己很聰明XD)。 第三版有了前面的燒腦計算(數學真的很差QQ)，跟旋轉動畫的使用經驗，搭配使用canvas做圖好方便阿，把餅圖跟文字一併在canvas中產出，製作途中一直想到一些額外的通用設定，就增修增修，然後變成現在這樣，原本想要全部都自己刻，但想到表單類的刻起來實在太累，就直接用BS4來處理設定視窗了。 幫助很多的參考資料rotate+skew的餅圖畫法參考這篇https://www.jianshu.com/p/2acce3d9c8bd canvas的餅圖畫法參考這篇https://www.jianshu.com/p/94fddad3443f]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Fun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli透過webpack來加載使用pug/scss及BootStrap4]]></title>
    <url>%2F2017%2F12%2Fvue-cli-webpack-pug-scss-bootstrap4%2F</url>
    <content type="text"><![CDATA[這兩週一直在看BootStrap4跟Vue，真的覺得好好玩啊！在此紀錄Vue-cli中使用pug/scss/BootStrap4的方法。 Step1. 安裝Vue-cli透過npm指令來安裝全域Vue-cli1$ npm install -g vue-cli 安裝完畢後，建立一個vue-cli的專案吧！1$ vue init webpack [project-name] 接著就會出現設定畫面，我設定如下(附上備註)1234567891011121314151617181920// 專案名稱(不可包含大寫)? Project name vue-base// 專案備註? Project description A Vue.js project// 作者? Author GuaHsu &lt;guaswork@gmail.com&gt;// ? Vue build standalone// 是否安裝vue-router? Install vue-router? Yes// 是否啟用ESLint? Use ESLint to lint your code? Yes// 如果啟用ESLint，可以選規範，我是選Airbnb? Pick an ESLint preset Airbnb// 我沒用：D? Set up unit tests No// 我沒用：D? Setup e2e tests with Nightwatch? No// 我選用npm? Should we run `npm install` for you after the project has been created? (recommended) npm Step2. 安裝pug / pug-loader / pug-filters使用npm指令1npm install pug pug-loader pug-filters --save Step3. 安裝Sass / Sass-loader / node-sass使用npm指令1npm install sass sass-loader node-sass --save Step4. 安裝BootStrap / jQuery / Popper由於BootStrap4的不少元件會使用到jQuery與Popper，會用到BS應該很少單純只使用CSS部份的，這裡是全安裝的設置，一樣使用npm指令安裝123npm install bootstrap@4.0.0-beta.2 --savenpm install --save jquerynpm install --save popper.js 接著到build/webpack.base.conf.js加入以下設定1234567891011121314// 最上方加入一個webpackconst webpack = require('webpack')module.exports = &#123; ... // 新增plugins plugins: [ new webpack.ProvidePlugin(&#123; '$': "jquery", 'jQuery': "jquery", 'Popper': 'popper.js' &#125;) ], ...&#125; 在到src/main.js中把BootStrap載入123// 新增這兩行BootStrap的東西import 'bootstrap';import 'bootstrap/dist/css/bootstrap.css'; Step 5. 使用！來用pug + scss + BootStrap來寫vue的元件吧這裡用預設的範例改，檔案位置src/components/HelloWorld.vue 要用pug的template必須加上lang=&quot;pug&quot; 要用scss的style必須加上lang=&quot;scss&quot; 此範例template內容為bootstrap的modal元件 123456789101112131415161718192021222324252627282930313233343536&lt;template lang="pug"&gt;.hello h1 &#123;&#123; msg &#125;&#125; button.btn.btn-success(data-toggle="modal", data-target="#exampleModal") Demo #exampleModal.modal.fade .modal-dialog(role="document") .modal-content .modal-header h5.modal-title Modal Title button.close(data-dismiss="modal") span &amp;times; .modal-body p hello!hello! .modal-footer button.btn.btn-success save button.btn.bth-secondary(data-dismiss="modal") cancle&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data() &#123; return &#123; msg: 'Pug / Scss / BootStrap / jQuery', &#125;; &#125;,&#125;;&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style lang="scss" scoped&gt;$vue-color: #42b983;h1 &#123; color: $vue-color;&#125;&lt;/style&gt; 另一種選擇 BootStrap-Vue這是在爬文時看到的，例如同樣以modal作範例只要寫這樣就好：1234&lt;b-btn v-b-modal.modal1&gt;Launch demo modal&lt;/b-btn&gt;&lt;b-modal id="modal1" title="Bootstrap-Vue"&gt; &lt;p class="my-4"&gt;Hello from modal!&lt;/p&gt;&lt;/b-modal&gt; 他已經包好了，也因為包好好的所以在學習與協作上會有額外的學習成本，必須了解元件的寫法，也未知若要調整元件的控制是否會有其他困難度.. Vue與jQuery的混用在Vue.js中使用BootStrap不可避免的會需要用到jQuery，比較擔心在撰寫方面會有混用的狀況(不確定實務上該是否該分離較佳)。 在群組也有人分享可以用vue來操作，例如modal的data-dismiss=&quot;close&quot;可以改用@click偵聽，在透過data給個變數放true/false判斷來透過v-show控制開關。 但就必須要更了解BootStrap裡面用到的JS控制邏輯並改為vue控制像是原本會有這種偵聽關閉事件的函式就得要在改寫掉了：123$('#myModal').on('hidden.bs.modal', function (e) &#123; // do something...&#125;)]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>BootStrap</tag>
        <tag>webpack</tag>
        <tag>scss</tag>
        <tag>pug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO-NexT的Local Search轉圈圈問題]]></title>
    <url>%2F2017%2F12%2FHexo-Next-LocalSearch-cant-work%2F</url>
    <content type="text"><![CDATA[有時候更新完文章，會莫名導致NexT的LocalSearsh有問題，像是上圖一樣的卡住轉圈圈狀態也沒辦法解掉，這篇紀錄如何解決。 之前有時偶爾會更新時發現這種問題，都會回去markdown檔案中檢視看看哪裡是否誤用非法字元，然後把文章修改一下，就也沒追根究柢通常就是把出錯那段文字改掉XD 直到上次因為JavaScript30系列把所有文章內容都加上了列表站的連結，導致搜尋一直有問題，才開始去翻找原因 Step1. 檢查搜尋機制由於使用的是localSearch，會透過編譯完後public裡面的search.xml作為搜尋主體，有了搜尋主體後就要先去驗證格式的正確性，但我跟XML格式並不熟，內容量太大也沒辦法肉眼去驗證，就找了線上驗證的網站，把search.xml的內容全部丟下去驗證後跳出了這個錯誤。 線上找會有很多，我是用google找到的第一個https://www.xmlvalidation.com/ Step2. Unicode: 0x8得到了這樣子的錯誤訊息後，就馬上拿去問google啦~也發現從標題中有滿多人是在跟md檔案有關係的互動時產生的問題，點了其中一篇GitHub中關於EverNote的發問，裡面有人回應這個錯誤是因為產生了一個backspace的字符，順著查下去！ Step3. 顯示看不到的backspace字符我是使用VSCODE，開啟方式是到設定中打開renderControlCharacters打開之後就可以看到兇手了！ Step4. 搜尋並替換經過查詢，backspace的unicode是\u0008，而VSCODE的檔案搜尋正則表達式使用的是Rust要輸入\x{0008}，但是我查了很久總是搜不出我要的檔案，我也不知道哪裡出錯，就這樣查了很久很久才發現，直接把那個超小的bs框起來複製丟上搜尋框就好！！！雖然搜尋框內的bs肉眼看不到，但是實際上他會去進行搜尋，接著就一個一個替換吧（一個一個替換是因為我只替換我自己產出的檔案，避免影響其他東西）。 Step5. 重編譯一次測試看看吧當完成修改後，重新測試理論上搜尋框就修好了～～找原因的途中也是學了不少啊：D]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
        <tag>NEXT</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」完結 ＆ Gif切換與loading效果]]></title>
    <url>%2F2017%2F11%2FJavaScript30-Final-Gif-Loader%2F</url>
    <content type="text"><![CDATA[JavaScript30系列終於完成啦！！寫了一個列表網站擺放每一篇的練習概要與截圖，這個列表站也是沒使用任何外部函式庫與框架，最後一篇紀錄這個小站中做的靜/動態圖切換、loading效果。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 目的想法很單純，就只是因為gif的檔案較大若網站一次全讀會造成一些延遲，但若使用lazyload的方式則是預設情況下gif會一直自己動造成畫面的混亂，所以想設計成當要他動時在動，就像是影片網站的動態預覽一樣，所以再我能力不足以去切割gif影格的狀態下，最快就是放png/gif來切換了，而在切換gif後的載入難免會有延遲需要等待，就想做個轉圈圈讓人知道他有在做事XD 開始吧！ HTMLHTML的結構： photo: 這次要做的整個圖片事件外框 photo–hasGif: 標記這裡面有gif可作切換用，若不用切換則不用給這個class photo__load: 載入動畫用 photo__img: 圖片本體 1234&lt;div class="photo photo--hasGif"&gt; &lt;div class="photo__load"&gt;&lt;/div&gt; &lt;img class="photo__img" src="https://guahsu.io/2017/05/JavaScript30-01-Java-Script-Drum-Kit/demo1.png"&gt;&lt;/div&gt; CSS圖片框hover時的浮起效果與讀取轉圈圈特效。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.photo &#123; position: relative; display: inline-block; margin: 0px 15px; width: 400px; background-color: #fafafa; /* 加上陰影與transition時間，讓hover時有浮起來的感覺 */ box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24); transition: 0.5s;&#125;.photo:hover &#123; box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);&#125;.photo__img &#123; max-width: 100%;&#125;.photo__load &#123; display: none; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; /* 為了讓載入圖示像是載入圖示再轉的樣子， 把四個邊的其中一邊(這裡是bottom)設為透明， 再透過border-radius設成圓型， */ border: 5px solid #fafafa; border-bottom: 5px solid transparent; border-radius: 100%; background-color: transparent; /* 使用animation動畫，線性且無限循環 呼叫動畫rotate */ animation: 1.5s linear infinite rotate;&#125;/* 旋轉動畫，就是從0度轉到360無限循環 而裡面的translate是為了讓加載圖示對齊圖片中心， 也就是常見的left: 50% + translateX(-50%)這種做法， 但因為有用到animation必須把translate設在keyframes裡面。*/@keyframes rotate &#123; from &#123; transform: translate(-50%, -50%) rotate(0deg); &#125; to &#123; transform: translate(-50%, -50%) rotate(360deg); &#125;&#125; JavaScript作圖片副檔名的切換與圖片讀取檢查(轉圈圈判斷)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** 圖片讀取檢查 */function checkLoad(image) &#123; // 取得觸發事件photo中的加載圖示 var loadIcon = image.parentElement.querySelector('.photo__load'); setTimeout(function() &#123; // 用complete檢查圖片是否已加載完成 if (image.complete) &#123; // 已加載完成就把加載圖示隱藏 loadIcon.style.display = 'none'; &#125; else &#123; // 未完成就顯示加載圖示並在呼叫自己一次 loadIcon.style.display = 'block'; checkLoad(image); &#125; &#125;, 100);&#125;/** 變更圖片類別(滑鼠移入載GIF移出換回PNG) */function changeImgaeType() &#123; // 判斷傳入的photo是否有gif，若沒有就跳出這個function if (this.classList.contains('photo--hasGif')) &#123; var type = []; // 取得觸發事件的photo裡面圖片本體 var image = this.querySelector('.photo__img'); // 檢查是否已經轉為gif播放中 var isPlay = image.classList.contains('photo__img--play'); // 播放判斷 if(isPlay) &#123; // 如果播放中，就移除播放標記(mouseleave時會觸發)並寫好轉換用的type值 image.classList.remove('photo__img--play'); type = ['gif', 'png']; &#125;else &#123; // 如果未播放，就新增播放標記(mouseenter時會觸發)並寫好轉換用的type值 image.classList.add('photo__img--play'); type = ['png', 'gif']; &#125; // 取得圖片連結(原本的src圖片連結，替換掉副檔名) var imageLink = image.getAttribute('src').replace(type[0], type[1]); // 設定新的圖片連結到原本的圖片本體中 image.setAttribute('src', imageLink); // 檢查讀取 checkLoad(image); &#125;&#125;/* 因為querySelectorAll取回的不是Array是NodeList並不存在forEach方法， 所以透過Array.from()把取回的NodeList轉Array，接著再用forEach為每個photo加上滑鼠事件的監聽 */var photos = Array.from(document.querySelectorAll('.photo'));photos.forEach(photo =&gt; &#123; photo.addEventListener('mouseenter', changeImgaeType); photo.addEventListener('mouseleave', changeImgaeType);&#125;);]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」30 - Whack A Mole]]></title>
    <url>%2F2017%2F11%2FJavaScript30-30-Whack-A-Mole%2F</url>
    <content type="text"><![CDATA[主題JS30的最終篇啦！這次要來做一個打地鼠的小遊戲:D [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 取得頁面元素並設定預設變數123456789/** 取得頁面元素 */const holes = document.querySelectorAll('.hole');const scoreBoard = document.querySelector('.score');const moles = document.querySelectorAll('.mole');/** 預設變數設定 */let lastHole; // 最後一次出現的地鼠洞let timeUP = false; // 遊戲時間是否結束戳記let score = 0; // 分數 Step2. 亂數決定地鼠出現後存在的時間&amp;地鼠出現的洞123456789101112131415161718/** 地鼠出現後存在時間，傳入最小&amp;最大值，回傳一個區間亂數 */function randomTime(min, max) &#123; return Math.round(Math.random() * (max - min) + min);&#125;/** 地鼠出現的洞 */function randomHole(holes) &#123; // 取得地鼠洞數量區間內隨機一個洞 const idx = Math.floor(Math.random() * holes.length); const hole = holes[idx]; // 避免骰到相同的 if (hole === lastHole) &#123; return randomHole(holes); &#125; // 紀錄最後一個出現的地鼠洞 lastHole = hole; return hole;&#125; Step3. 地鼠出現的主程式12345678910111213141516/** 地鼠出現 */function peep() &#123; // 取得存在時間 const time = randomTime(300, 1000); // 取得出現的洞 const hole = randomHole(holes); // 移除已槌標記 hole.querySelector('.mole').classList.remove('bonked'); // 增加出現的動畫class hole.classList.add('up'); // 設定存在時間到的時候移除出現動畫，且若遊戲時間未結束就繼續跑下一run setTimeout(() =&gt; &#123; hole.classList.remove('up'); if (!timeUP) peep(); &#125;, time)&#125; Step4. 打地鼠12345678910111213/** 打地鼠 */function bonk(e) &#123; // isTrusted防止腳本操作，class有bonked代表已被搥過，若符合上述兩者則不進行 if(!e.isTrusted || this.classList.contains('bonked')) return; // 替被打到的地鼠加上bonked的樣式避免連續點擊得分 this.classList.add('bonked'); // 打到就移除出現的動畫 this.classList.remove('up'); // 加分 score++; // 更新顯示分數 scoreBoard.textContent = score;&#125; Step5. 開始遊戲設定，並綁定打地鼠動作到每個地鼠身上123456789101112131415/** 開始遊戲 */function startGame() &#123; // 時間重置 timeUP = false; // 分數歸零 scoreBoard.textContent = 0; score = 0; // 執行地鼠出現函式 peep(); // 設定十秒後把時間押為結束 setTimeout(() =&gt; timeUP = true, 10000);&#125;// 替每個地鼠加上click事件綁定bonk（打地鼠）moles.forEach(mole =&gt; mole.addEventListener('click', bonk)); 程式備註 Event.isTrusted 可以透過此屬性來判斷事件物件是否由使用者操作來產生，而非透過程式觸發的操作。 參閱：MDN-Event.isTrusted 探索寫在上面了，原本可以連續點擊得分，加上個class做標記來防止連續點擊得分:D 其他終於把這系列練習完了！接著這週找時間整理全系列文章在丟回作者的github連結內:D!!]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Mac」更新CommandLine後無法使用git指令問題]]></title>
    <url>%2F2017%2F11%2Fmac-update-cant-use-git%2F</url>
    <content type="text"><![CDATA[昨天更新Ｍac的Command Line Tools後發現使用git指令無法使用：123xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解決方式是在命令列下xcode-select --install後下載完就可以使用了。]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>CommandLine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」29 - Countdown Timer]]></title>
    <url>%2F2017%2F11%2FJavaScript30-29-Countdown-Timer%2F</url>
    <content type="text"><![CDATA[主題製作一個倒數計時器。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 取得頁面元素並替預設123const timerDisplay = document.querySelector('.display__time-left');const endTime = document.querySelector('.display__end-time');const buttons = document.querySelectorAll('[data-time]'); Step2. 設定計時器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 外層變數，供計時器主體使用let countdown; /** 計時器 **/function timer(seconds) &#123; // 新的計時器被啟動時，先把原本的setInterval清除 clearInterval(countdown); // 取得時間 const now = Date.now(); const timeStamp = now + seconds * 1000; // 倒數計時與結束的時間顯示function displayTimeLeft(seconds); displayEndTime(timeStamp); // 計時器執行在countdown裡面方便接著清除使用 countdown = setInterval(() =&gt; &#123; // 取得要跑的總時長 const secondsLeft = Math.round((timeStamp - Date.now()) / 1000); // 如果時間已經小於零，結束這個Interval if(secondsLeft &lt; 0) &#123; clearInterval(countdown); return; &#125; // 更新時間 displayTimeLeft(secondsLeft); &#125;, 1000);&#125;// 顯示倒數時間function displayTimeLeft(seconds) &#123; // 透過Math.floor來取得分鐘數(傳入秒數/60取得最大整數) const minutes = Math.floor(seconds /60); // 用％來取得傳入秒數除60的餘數（扣除分鐘數後的秒數） const remainderSeconds = seconds % 60; console.log(&#123;minutes, remainderSeconds&#125;); // 顯示秒數的部分若小於0數字前補0 const display = `$&#123;minutes&#125;:$&#123;remainderSeconds &lt; 10 ? '0' : ''&#125;$&#123;remainderSeconds&#125;`; // 顯示對應時間 document.title = display; timerDisplay.textContent = display;&#125;// 顯示結束時間function displayEndTime(timestamp) &#123; // 用傳入的timestamp在取得date資訊 const end = new Date(timestamp); // 從date取得小時數 const hour = end.getHours(); // 轉12小時制 const adjustedHour = hour &gt; 12 ? hour - 12 : hour; // 從date取得分鐘數 const minutes = end.getMinutes(); // 顯示結束時間，與上方一樣，若分鐘數小於10，則前面補0 endTime.textContent = `Be Back At $&#123;hour&#125;:$&#123;minutes &lt; 10 ? '0' : ''&#125;$&#123;minutes&#125;`;&#125; Step3. 預設的固定時間倒數按鈕12345678910// 開始計時（HTML畫面設定好的時間）function startTimer() &#123; // 取得html中設定的data-time（秒數） const seconds = parseInt(this.dataset.time); // 傳入計時器function timer(seconds);&#125;// 替每個時間按鈕加上監聽click事件，用來啟動計時functionbuttons.forEach(button =&gt; button.addEventListener('click', startTimer)); Step4. 自訂時間倒數1234567891011// HTML中的input自訂倒數時間輸入欄位監聽document.customForm.addEventListener('submit', function(e) &#123; // 因為用form，submit後避免跳頁使用preventDefault()來阻止預設事件 e.preventDefault(); // 取得input欄位的值 const mins = this.minutes.value; // 傳入計時器 timer(mins * 60); // 清空input this.reset();&#125;) 其他這篇練習也算是相對簡單的時間，主要是學著用變數把setInterval內容包住，並且運用clearInterval來避免多個計時器啟動。]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」28 - Video Speed Controller]]></title>
    <url>%2F2017%2F10%2FJavaScript30-28-Video-Speed-Controller%2F</url>
    <content type="text"><![CDATA[主題製作一個可控制影片速率的拉把。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 這個練習可以算是延續「JS30紀錄＆心得」11 - Custom Video Player的操作，主要是把原本input range改成div的滑鼠事件監聽。 步驟Step1. 取得頁面元素123const speed = document.querySelector('.speed');const bar = speed.querySelector('.speed-bar');const video = document.querySelector('.flex'); Step2. 建立滑鼠移動監聽與事件12345678910111213141516171819/** 滑鼠移動事件 **/function handleMove (e) &#123; // 取得觸發點位置（滑鼠位於整頁頂端的Y軸定位-speed框到整頁頂端的距離） const y = e.pageY - this.offsetTop; // 設定百分比(y / speed框的高度) const percent = y / this.offsetHeight; const min = 0.4; const max = 4; // 用Math.round來計算取得四捨五入的百分比值 const height = Math.round(percent * 100) + '%'; // 取得播放速率(0.4一跳，最多4倍速) const playbackRate = percent * (max - min) + min; // 調整speed-bar的樣式高度 bar.style.height = height; // 用toFixed(2)來設定最多取得小數點後兩位，顯示於speed-bar上 bar.textContent = playbackRate.toFixed(2) + 'x'; // 控制影片的速率 video.playbackRate = playbackRate;&#125;]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CSScomb」好用的CSS屬性排版插件]]></title>
    <url>%2F2017%2F10%2FCSScomb-css-sort-format%2F</url>
    <content type="text"><![CDATA[超棒的CSS屬性排版插件，依據屬性類別擺好排好超舒服：D 起因是每次刻畫面都邊想邊寫CSS，這裡補一下那裡補一下的，常常寫好裡面屬性擺放的亂七八糟，有時會要再手動去排序讓自己找屬性時比較好找.. 所以就在找CSS的排序工具，昨天發問後在群組有人分享了Sort Lines這個插件，他可以依據選取範圍來做a-z正排序或反向排序，但是變成要很勤勞的選取-&gt;排序。 然後今天早上找找看到了CSScomb這個插件，使用起來就像首圖一樣，直接會把屬性分門別類排好，省去很多手動排的功夫，也讓心情變好了(?)。 安裝步驟(VScode)Step1. 安裝在VScode的擴充市集中可以找到，安裝後重新載入。 Step2. 插件設定進入設定介面後在使用者設定中，搜尋CSScomb，接著在csscomb.preset點選在設定中取代。到使用者設定的區塊，在把格式設定填入，有三種格式可選(csscomb, yandex, zen) Step3. 快捷鍵設定進入快捷鍵設定介面 點選搜尋框下面的keybindings.json(紅框處) 在這裡可以設定對應的熱鍵，要啟動的命令就是CSScomb啦～ Step4. 完成然後就開啟CSS檔，愉悅地按下熱鍵吧哈哈哈！]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Tools</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」27 - Click and Drag]]></title>
    <url>%2F2017%2F10%2FJavaScript30-27-Click-and-Drag%2F</url>
    <content type="text"><![CDATA[主題製作一個可拖曳移動的水平捲軸。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 取得頁面元素與設定初始變數1234const slider = document.querySelector('.items');let isDown = false;let startX;let scrollLeft; Step2. 建立基本事件框架因為這次練習主要是在拖曳的動作，所以對會用到的mouse event事件先建立監聽框框出來：12345678910111213141516171819/** 滑鼠按鍵按下 **/slider.addEventListener('mousedown', () =&gt; &#123;&#125;);/** 滑鼠滑出範圍**/slider.addEventListener('mouseleave', () =&gt; &#123;&#125;);/** 滑鼠按鍵放開 **/slider.addEventListener('mouseup', () =&gt; &#123;&#125;);/** 滑鼠移動 **/slider.addEventListener('mousemove', () =&gt; &#123;&#125;); Step3. 滑鼠按下事件12345678910slider.addEventListener('mousedown', (e) =&gt; &#123; // 給予按下的flag isDown = true; // 加上抓取效果樣式 slider.classList.add('active'); // 設定移動的初始值為目前頁面距離-當前item左邊距 startX = e.pageX - slider.offsetLeft; // 設定目前捲軸的左距 scrollLeft = slider.scrollLeft;&#125;); Step4. 滑鼠移出事件12345slider.addEventListener('mouseleave', () =&gt; &#123; // 將按下的flag與樣式移除 isDown = false; slider.classList.remove('active');&#125;); Step5. 滑鼠按鍵放開事件與Step4一樣，主要是取消樣式12345slider.addEventListener('mouseup', () =&gt; &#123; // 將按下的flag與樣式移除 isDown = false; slider.classList.remove('active');&#125;); Step6. 滑鼠移動事件123456789101112slider.addEventListener('mousemove', (e) =&gt; &#123; // 若移動時的狀態非按下，不作動 if (!isDown) return; // 避免觸發其他預設事件（按下且移動預設是選取範圍） e.preventDefault(); // 設定X（當前定位）為目前頁面距離-當前item左邊距 const x = e.pageX - slider.offsetLeft; // 設定移動距離為 X-初始值 const walk = x - startX; // 設定水平捲軸的偏移量 slider.scrollLeft = scrollLeft - walk;&#125;); 其他如果有仔細看，會發現當拖曳左右移動時，HTML中的卡片會有3D移動的效果感很褲，這是CSS的rotateY效果:123/* 用scaleX與rotateY搭配使移動時有3D效果 */.item:nth-child(even) &#123; transform: scaleX(1.31) rotateY(40deg); &#125;.item:nth-child(odd) &#123; transform: scaleX(1.31) rotateY(-40deg); &#125; 參閱：MDN-rotateY()]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」26 - Stripe Follow Along Nav]]></title>
    <url>%2F2017%2F10%2FJavaScript30-26-Stripe-Follow-Along-Nav%2F</url>
    <content type="text"><![CDATA[主題延續上次的練習JS30紀錄＆心得」22 - Follow Along Link Highlighter，這次用相同的原理來製作一個隨著滑鼠移動展開的選單效果。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 取得頁面元素與建立基本事件框架取得頁面元素並分析此次效果僅有兩個事件mouseenter與mouseleave，確定好知道目前要做的範圍，就先把function框建立好。12345678910111213141516// 頁面元素取得const triggers = document.querySelectorAll('.cool &gt; li');const background = document.querySelector('.dropdownBackground');const nav = document.querySelector('.top');// 滑鼠移入事件function handleEnter() &#123;&#125;// 滑鼠移出事件function handleLeave() &#123;&#125;// 為每個選單加上滑鼠移入/移出事件監聽triggers.forEach(trigger =&gt; trigger.addEventListener('mouseenter', handleEnter));triggers.forEach(trigger =&gt; trigger.addEventListener('mouseleave', handleLeave)); Step2. 撰寫移入事件編寫當滑鼠移入時被觸發的事件，備註如下：12345678910111213141516171819202122232425262728293031// 滑鼠移入事件function handleEnter() &#123; // 替觸發的li加上一個class作為標示已移入 this.classList.add('trigger-enter'); // 當移入時，先檢查是否有trigger-enter這個className // 若有的話在150毫秒後新增trigger-enter-active這個class setTimeout(() =&gt; this.classList.contains('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 150); // 新增open這個class background.classList.add('open'); // 取得滑入元素底下的dropdown const dropdown = this.querySelector('.dropdown'); // 取得這個dropdown的定位與大小資訊 const dropdownCoords = dropdown.getBoundingClientRect(); // 取得nav的定位與大小資訊 const navCoords = nav.getBoundingClientRect(); // 設定將要給白色滑動背景使用的定位與大小資訊 const coords = &#123; height: dropdownCoords.height, width: dropdownCoords.width, // 要減去nav的定位，避免上方區塊增加時造成的錯位 top: dropdownCoords.top - navCoords.top, left: dropdownCoords.left - navCoords.left &#125;; // 設定白色滑動背景的定位與大小 background.style.setProperty('width', `$&#123;coords.width&#125;px`); background.style.setProperty('height', `$&#123;coords.height&#125;px`); background.style.setProperty('transform', `translate($&#123;coords.left&#125;px, $&#123;coords.top&#125;px)`);&#125; Step3. 撰寫移出事件簡單的移除被加上的class：1234function handleLeave() &#123; this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');&#125; 其他利用JS取得定位及大小資訊，並在適時置入對應元素中，產生的動畫效果還得靠CSS，這練習主要是靠這兩個來產生效果:1234567891011121314151617.dropdownBackground &#123; width: 100px; height: 100px; position: absolute; background: #fff; border-radius: 4px; box-shadow: 0 50px 100px rgba(50, 50, 93, .1), 0 15px 35px rgba(50, 50, 93, .15), 0 5px 15px rgba(0, 0, 0, .1); transition: all 0.3s, opacity 0.1s, transform 0.2s; transform-origin: 50% 0; display: flex; justify-content: center; opacity: 0;&#125;.dropdownBackground.open &#123; opacity: 1;&#125;]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」25 - Event Capture, Propagation, Bubbling and Once]]></title>
    <url>%2F2017%2F10%2FJavaScript30-25-Event-Capture-Propagation-Bubbling-and-Once%2F</url>
    <content type="text"><![CDATA[主題解析addEventListener中事件的捕捉、傳遞、氣泡與單次執行方法 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 建立事件模型與基本呼叫首先建立三層DIV作為稍後測試使用的模型，依序包覆為：紫色&gt;淺橘色&gt;深橘色123456&lt;div class="one"&gt; &lt;div class="two"&gt; &lt;div class="three"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 接著建立click事件12345678910// 取得頁面的所有divconst divs = document.querySelectorAll('div');function logText(e) &#123; // 印出當前div的class name console.log(this.classList.value);&#125;// 為每個div加上click事件監聽divs.forEach(div =&gt; div.addEventListener('click', logText)); Step2. 預設的點擊事件當對著畫面中間(深橘色/one)做點擊時，console印出來的是123threetwoone 會從click的位置的最深處開始向外層連動所有的divclick事件，像是氣泡一樣的從內向外浮出去。 Step3. addEventListener的第三個參數-1:capture深入檢查，會發現其實addEventListener是有第三個參數的：123divs.forEach(div =&gt; div.addEventListener('click', logText, &#123; capture: false, // 預設為false&#125;)); 第三個參數的第一個屬性Capture就是事件的捕捉順序，剛剛提到click後console印出來順序是由內向外，若將Capture設為true會在點擊中間(深橘色/one)會印出：1one 就只有印出one而已，這是因為對當前最外層的容器one去點了，就已經捕捉到目的了，所以他不會再往下找，只會到點擊的最外層目標為止。 Step4. stopPropagation()但如果想從內層往外層點，而且是依選取層印出對應層級的話，就要在列印的function加上topPropagation()來使用：1234function logText(e) &#123; console.log(this.classList.value); e.stopPropagation(); // stop bubbling!&#125; 這會使原本向外延伸的氣泡事件停止。 Step5. addEventListener的第三個參數-2:once而addEventListener的第三參數還有一個新屬性once，新增一個按鈕的click事件來測試：12345button.addEventListener('click', () =&gt; &#123; console.log('Click!!!');&#125;, &#123; once: true&#125;); 它可以使這個按鈕click被執行結束後，直接unbind這個元素與事件，之後這個按鈕就已經不會再被觸發click事件了！可以運用在很多避免重複點擊的狀況，例如表單送出後禁止user重複點擊。 其他在一開始的練習JavaScript練習-臺北市旅遊景點時也有記錄到這個第三參數，但當時只知道capture並不曉得once，對於整體的事件捕捉也不是很清楚，經由這個練習範例加深了這個印象，雖然目前還是沒有正式運用到，但這個觀念記著不吃虧，之後遇到相關問題會有更多可以思考的腦中資料：）。]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」24 - Sticky Nav]]></title>
    <url>%2F2017%2F10%2FJavaScript30-24-Sticky-Nav%2F</url>
    <content type="text"><![CDATA[主題透過CSS的position:fixed與JavaScript的classList來製作網站常見的置頂選單。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 取得頁面元素並偵測選單到頂部的高度1234// 取得nav元素const nav = document.querySelector('#main');// 透過offsetTop取得nav頂部到整個page的頂部距離let topOfNav = nav.offsetTop; Step2. 對CSS增加樣式fixed-nav12345678910111213/* 當有fixed-nav時，把site-wrap縮放回1，讓整體有放大效果*/.fixed-nav .site-wrap &#123; transform: scale(1);&#125;/* 當有fixed-nav時，把nav改為fixed並加上陰影*/.fixed-nav nav &#123; position: fixed; box-shadow: 0 5px rgba(0,0,0,0.1);&#125;/* 當有fixed-nav時，把logo寬度增加，使其顯示出來*/.fixed-nav li.logo &#123; max-width: 500px;&#125; Step3. 進行網頁捲軸高度偵測，決定是否變更選單樣式12345678910111213141516function fixNav() &#123; // 如果目前捲軸的高度高過於nav的頂部 if (window.scrollY &gt;= topOfNav) &#123; /* 設定一個padding-top並增加fixed-nav 因為當position被設定為fixed時，將不會再佔據原有的高度 所以要動態的增加一個offsetHeight來將內容部位增高避免怪異的彈跳遮擋現象 */ document.body.style.paddingTop = nav.offsetHeight + 'px'; document.body.classList.add('fixed-nav'); &#125; else &#123; // 還原padding-top並移除fixed-nav document.body.style.paddingTop = 0; document.body.classList.remove('fixed-nav'); &#125;&#125;// 監聽scroll動作window.addEventListener('scroll', fixNav); 其他這個也是比較基礎的小練習，比較特別的是體驗到網站切換時使用transform: scale()來作些微縮放在視覺上感受滿棒的。]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」23 - Speech Synthesis]]></title>
    <url>%2F2017%2F10%2FJavaScript30-23-Speech-Synthesis%2F</url>
    <content type="text"><![CDATA[主題使用SpeechSynthesisUtterance及speechSynthesis來使文字轉語音。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 上次有做過語音轉文字的練習[20 - Speech Detection]，這次則是要使用文字轉語音，透過介面中的輸入欄位來轉語音播放，並可透過設定好的控制條來變更語音速率/音準。 步驟Step1. 取得頁面元素並設置SpeechSynthesisUtterance12345678const msg = new SpeechSynthesisUtterance();let voices = [];const voicesDropdown = document.querySelector('[name="voice"]');const options = document.querySelectorAll('[type="range"], [name="text"]');const speakButton = document.querySelector('#speak');const stopButton = document.querySelector('#stop');// 使html中的輸入欄位成為SpeechSynthesisUtterance要使用的值msg.text = document.querySelector('[name="text"]').value Step2. 設定語音播放語系選單1234567891011121314// 取得語系資訊 function populateVoices() &#123; voices = this.getVoices(); // 將所有語系塞進下拉選單中 voicesDropdown.innerHTML = voices // 使用filter篩選出包含zh及en的語系 .filter(voice =&gt; voice.lang.includes('zh') || voice.lang.includes('en')) // 篩選後的array透過map把資料組成html .map(voice =&gt; `&lt;option value=$&#123;voice.name&#125;&gt;$&#123;voice.name&#125; ($&#123;voice.lang&#125;)&lt;/option&gt;`) // 用join來合併且消除原本陣列的逗點 .join('');&#125;// 監聽語音清單變更後進行語系清單的更新speechSynthesis.addEventListener('voiceschanged', populateVoices); Step3. 播放與功能設定123456789101112131415161718192021222324252627// 播放切換function toggle(starOver = true) &#123; speechSynthesis.cancel(); if (starOver) &#123; speechSynthesis.speak(msg); &#125;&#125;// 設定選擇的發音語系function setVoice() &#123; msg.voice = voices.find(voice =&gt; voice.name === this.value); toggle();&#125;// 設定速率跟音準function setOption() &#123; // 傳入的變數名稱與SpeechSynthesisUtterance本身的物件相同 // 所以可以透過這種方式來直接用 msg[this.name] = this.value; toggle();&#125;// 監聽語系選單，選擇後切換語系voicesDropdown.addEventListener('change', setVoice);// 監聽速率跟音準控制條，移動後設定options.forEach(option =&gt; option.addEventListener('change', setOption));// 播放按鈕speakButton.addEventListener('click', toggle);// 停止按鈕stopButton.addEventListener('click', () =&gt; toggle(false)); 語法&amp;備註SpeechSynthesisUtterance可以設置語音服務應讀取的文字內容及播放的細節(語系、速率、音量..等屬性) 參閱：MDN-Element.getBoundingClientRect() SpeechSynthesis執行語音服務的主要功能，包含了播放、暫停..等屬性 參閱：MDN-SpeechSynthesis]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>SpeechSynthesis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」22 - Follow Along Link Highlighter]]></title>
    <url>%2F2017%2F10%2FJavaScript30-22-Follow-Along-Link-Highlighter%2F</url>
    <content type="text"><![CDATA[主題透過getBoundingClientRect與CSS的transform來達到HightLight樣式會跟著指定位置移動的效果。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 取得頁面元素1234567// 取得HTML中所有的a元素const triggers = document.querySelectorAll('a');// 建立一個span來放置highlight效果const highlight = document.createElement('span');highlight.classList.add('highlight');// 將建立的span加到頁面中document.body.append(highlight); Step2. 撰寫移入狀態用以下的JS對目標(a連結)定位並設定樣式12345678910111213141516171819// 效果function highlightLink() &#123; // 取得this(由a.addEventListener傳入，所以會是該a)的資訊 const linkCoords = this.getBoundingClientRect(); // 建立一個coords物件來存放會使用的寬高與定位資訊 const cords = &#123; width: linkCoords.width, height: linkCoords.height, left: linkCoords.left + window.scrollX, top: linkCoords.top + window.scrollY &#125; // 設定highlight效果的寬高及定位 highlight.style.width = `$&#123;cords.width&#125;px`; highlight.style.height = `$&#123;cords.height&#125;px`; highlight.style.transform = `translate($&#123;cords.left&#125;px, $&#123;cords.top&#125;px`;&#125;// 監聽所有a元素的滑鼠移入，觸發highlightLinktriggers.forEach(a =&gt; a.addEventListener('mouseenter', highlightLink)); 位移的效果主要來自已經寫好的css與js裡面重新定位的translate123456789101112.highlight &#123; transition: all 0.2s; border-bottom:2px solid white; position: absolute; top:0; background:white; left:0; z-index: -1; border-radius:20px; display: block; box-shadow: 0 0 10px rgba(0,0,0,0.2)&#125; 語法&amp;備註Element.getBoundingClientRect()返回目標元素的大小與相對於瀏覽器視窗的位置資訊 參閱：MDN-Element.getBoundingClientRect()]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小改樣式]]></title>
    <url>%2F2017%2F10%2Fmodify-blog-layout%2F</url>
    <content type="text"><![CDATA[Hexo的NexT主題很夯，好多人使用，常常爬文看到一樣的主題，無奈現在還沒時間寫自己的樣板，今天小改用回Muse及調整部分樣式來避免撞臉XD..]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Hexo-NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」21 - Geolocation]]></title>
    <url>%2F2017%2F10%2FJavaScript30-21-Geolocation%2F</url>
    <content type="text"><![CDATA[主題利用navigator.geolocation來取得裝置的地理位置與速率。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 啟動Local Server這個練習需要使用到local server，如果你已經有一個可在本機run起來的server可以直接使用，或在這層資料夾底下運行npm install來安裝browser-sync，安裝完成後可以透過指令npm start來啟動localserver(預設port3000)， npm指令需要下載node.js來使用 Step2. 測試由於這個練習是需要取得定位資訊，所以可以透過手機瀏覽器利用npm start啟動server後的內網ip來連線，或是使用Mac的Xcode開發工具來模擬移動中的裝置(影片教學是使用後者)。 Step3. 撰寫程式123456789101112131415// 取得HTML中的元素const arrow = document.querySelector('.arrow');const speed = document.querySelector('.speed-value');// 使用watchPosition來取得使用者的地理位置及海拔、速度navigator.geolocation.watchPosition((data) =&gt; &#123; // 若成功取回，則會回傳一組Position(這裡定義名稱為data) console.log(data); // 使用coords.speed取回速度(公尺/秒) speed.textContent = data.coords.speed; // 使用coords.heading取得方位，代表偏離北方的角度，0為正北、90為正東 arrow.style.transform = `rotate($&#123;data.coords.heading&#125;deg)`;&#125;, (err) =&gt; &#123; // 錯誤回傳訊息，例如未取得定位授權時 console.error(err);&#125;); 參閱：MDN-Geolocation]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Geolocation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」20 - Speech Detection]]></title>
    <url>%2F2017%2F10%2FJavaScript30-20-Speech-Detection%2F</url>
    <content type="text"><![CDATA[主題利用SpeechRecognition來做語音識別，並透過interimResults來輸出識別的結果。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 啟動Local Server這個練習需要使用到local server，如果你已經有一個可在本機run起來的server可以直接使用，或在這層資料夾底下運行npm install來安裝browser-sync，安裝完成後可以透過指令npm start來啟動localserver(預設port3000)， npm指令需要下載node.js來使用 Step2. 將SpeechRecognition建立起來123456// 將全域環境中的SpeechRecognition指好(依據不同瀏覽器)window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;// 建立一個變數recognition來放為語音識別功能const recognition = new SpeechRecognition();// 讓語音識別回傳識別後的資訊（預設為false)recognition.interimResults = true; 參閱：MDN-SpeechRecognition.interimResults Step3. 把輸出區域準備好1234// 建立一個p元素在html設定好的文字區中let p = document.createElement('p');const words = document.querySelector('.words');words.appendChild(p); Step4. 對識別系統做監聽識別回傳的資料是NodeList，所以要用map操作得先轉array123456789101112131415161718192021222324// 監聽識別回傳recognition.addEventListener('result', e =&gt; &#123; // 將回傳資料先轉為array來操作 const transcript = Array.from(e.results) // 透過map取得回傳陣列中的第0筆 .map(result =&gt; result[0]) // 在取得第0筆中的transcript .map(result =&gt; result.transcript) // 用join把連結符號消掉 .join('') // 把回傳內容塞到p元素中 p.textContent = transcript; // 如果回傳內容已經結束（一段話的結尾）在建立一個新的p元素來放下一段文字 if (e.results[0].isFinal) &#123; p = document.createElement('p'); words.appendChild(p); &#125;&#125;)// 監聽如果語音識別結束，則在開啟一次新的識別recognition.addEventListener('end', recognition.start);// 開始識別recognition.start(); 其他在測試的過程中，不知道是我發音的問題還是怎麼回事，我在說出localhost的過程中居然被識別成Tokyo HotXDDDD]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>SpeechRecognition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」19 - Webcam Fun]]></title>
    <url>%2F2017%2F10%2FJavaScript30-19-Webcam-Fun%2F</url>
    <content type="text"><![CDATA[主題利用navigator.mediaDevices.getUserMedia來取得視訊鏡頭影像，並透過cavas來達到拍照與濾鏡的效果。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 啟動Local Server這個練習需要使用到local server，如果你已經有一個可在本機run起來的server可以直接使用，或在這層資料夾底下運行npm install來安裝browser-sync，安裝完成後可以透過指令npm start來啟動localserver(預設port3000)， npm指令需要下載node.js來使用 Step2. 取得影像透過navigator.mediaDevices.getUserMedia來取得視訊影像1234567891011121314151617function getVideo() &#123; // 取得user的視訊裝置，回傳Promise狀態 navigator.mediaDevices.getUserMedia(&#123; video: true, audio: false &#125;) // 如果允許則把回傳的MediaStream寫進html的video tag中並播放 .then(localMediaStream =&gt; &#123; /* console.log(localMediaStream); */ video.src = window.URL.createObjectURL(localMediaStream); video.play(); &#125;) // 當失敗時印出錯誤結果 .catch(err =&gt; &#123; console.error(`ERROR: `, err); &#125;)&#125; 參閱：MDN-MediaDevices.getUserMedia() Step3. 取得視訊資料並輸出在cavas區塊中123456789101112function paintToCanavas() &#123; // 設置寬高 const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; // 用setInterval來持續取得目前的影像資訊 return setInterval(() =&gt; &#123; // 在canvas中設置內容來源與video相同，並且X、Ｙ軸及長寬與video相同 ctx.drawImage(video, 0, 0, width, height); &#125;, 16)&#125; 參閱：MDN-CanvasRenderingContext2D.drawImage() Step4. 製作拍照功能！1234567891011121314151617function takePhoto() &#123; // 拍照的音效-&gt;把音效切到第0秒並播放 snap.currentTime = 0; snap.play(); // 利用toDataURL把canvas的內容轉為base64的圖檔資訊 const data = canvas.toDataURL('image/jpeg'); // 用createElemamnt來建立一個新的a元素 const link = document.createElement('a'); // 設置連結位置為轉圖檔後的base64位置 link.href = data; // 設置連結為下載 link.setAttribute('download', 'photo'); // 內部新增一個預覽圖 link.innerHTML = `&lt;img src="$&#123;data&#125;" alt="photo" /&gt;`; // 在圖片區塞入新圖片（在第一筆的位置） strip.insertBefore(link, strip.firstChild);&#125; 參閱：MDN-HTMLCanvasElement.toDataURL()參閱：MDN-Node.insert Before() Step5. 濾鏡效果（紅色）再回到Step3的paintToCanavas()中新增：123456789101112function paintToCanavas() &#123; // ...略 return setInterval(() =&gt; &#123; ctx.drawImage(video, 0, 0, width, height); // 透過getImageData取得當前canvans中所有的像素點(r,g,b,alpha的資訊) let pixels = ctx.getImageData(0, 0, width, height); // 製作效果 pixels = redEffect(pixels); // 紅色濾鏡效果 // 置入效果 ctx.putImageData(pixels, 0, 0); &#125;, 16)&#125; 並新增一個對應的濾鏡functionredEffect()12345678910function redEffect(pixels) &#123; // 透過迴圈將取回的所有像素資料跑一次，i +=4 是因為四個一組(r,g,b,alpha） for (let i = 0; i &lt; pixels.data.length; i += 4) &#123; // 下面組合就是單純把R(紅色)增強達到紅色濾鏡的效果 pixels.data[i + 0] = pixels.data[i + 0] + 100; pixels.data[i + 1] = pixels.data[i + 1] - 50; pixels.data[i + 2] = pixels.data[i + 2] * 0.5; &#125; return pixels;&#125; 參閱：MDN-CanvasRenderingContext2D.getImageData()參閱:MDN-putImageData() 其他另外還有色彩分離與綠幕的濾鏡效果，基本上程式操作邏輯同Step5的紅色濾鏡效果，不過色彩的偏移設定我沒什麼顏色概念可以做說明..所以只能用紅色濾鏡作為說明&gt;&lt;..]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Mac」Spotify的歌詞顯示工具-LyricsX]]></title>
    <url>%2F2017%2F10%2FLyricsX-spotify-lyrics-for-mac%2F</url>
    <content type="text"><![CDATA[從使用Spotify到現在，最難過的就是內建歌詞顯示功能..(還有一堆中文歌找不到，有時候就是很想聽杰倫回味一下啊！) 然後今天再找的時候終於找到了一款好的歌詞程式LyricsX。 下載位置(GitHub)下載位置(App Store) 下載安裝後，全開介面如下有三個歌詞顯示位置如紅色框標示區，部分歌詞也可以再去搜尋其他歌詞（有些有中英文並行的）。 常常聽歌會突然很想知道歌詞的意思然後又拼不出單字，就會很需要歌詞顯示來幫忙找，不然就要去魔境歌詞網了XD。 裝了之後神清氣爽啊～～寫程式分心的能力增加了87%呢：） 還是有些缺點..歌詞來源還是有點雜，有時要微調或選別的詞檔..我想如果篩詞可以透過歌曲長度來找或許準度會再提升。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Spotify</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」18-Adding Up Times with Reduce]]></title>
    <url>%2F2017%2F10%2FJavaScript30-18-Adding-Up-Times-with-Reduce%2F</url>
    <content type="text"><![CDATA[主題利用map()與reduce()來取得播放清單的總秒數。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 取得全部的時間值在HTML中，時間資訊放在&lt;li data-time&gt;中，所以透過querySelectorAll來取得，因為接著會使用map及reduce操作，資料型態必須先轉為Array。12// 透過Array.from或是[...]來將querySelectorAll取回的NodeList轉Arrayconst timeNodes = Array.from(document.querySelectorAll('[data-time')); Step2. 將取回的資料轉為秒數並加總123456789101112const seconds = timeNodes // 取出每個元素中的data-time資料 .map(node =&gt; node.dataset.time) .map(timeCode =&gt; &#123; // 用解構賦值的方式分別取出split(':')後的分與秒 // 再透過一個map執行parseFloat將字串轉數值 const [mins, secs] = timeCode.split(':').map(parseFloat); // 回傳這組資料轉換後的總秒數 return (mins * 60) + secs; &#125;) // 用reduce來加總每次執行結果 .reduce((total, seconds) =&gt; total + seconds); Step3. 把總秒數轉為時分秒格式1234567// 利用取得的總秒數來進行總共時分秒的計算// 使用Math.floor取整數，再利用%來操作餘數let secondsLeft = seconds;const hours = Math.floor(secondsLeft / 3600);secondsLeft = secondsLeft % 3600;const mins = Math.floor(secondsLeft / 60);secondsLeft = secondsLeft % 60; Step4. 印出結果1console.log(`$&#123;hours&#125;:$&#123;mins&#125;:$&#123;secondsLeft&#125;`); 其他這篇也算是之前學習的再次運用，比較特別的是發現map中可以直接使用function！12345const [mins, secs] = timeCode.split(':').map(parseFloat);//等同於const [mins, secs] = timeCode.split(':').map(function(str)&#123; return parseFloat(str);&#125;);]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」17- Sort Without Articles]]></title>
    <url>%2F2017%2F10%2FJavaScript30-17-Sort-Without-Articles%2F</url>
    <content type="text"><![CDATA[主題介紹如何將陣列在排除部分文字的情況下排序。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 建立篩選的function使用replace搭配正規表示式來將包含了a, the, an開頭的文字替換為空白。123function strip(bandName) &#123; return bandName.replace(/^(a |the |an )/i, '').trim();&#125; Step2. 對目標陣列進行篩選與排序這裡將原本的寫法與簡寫放在一起，可以發現整體簡潔不少。12345678910//原本的寫法const sortedBands = bands.sort(function(a, b)&#123; if(strip(a) &gt; strip(b)) &#123; return 1; &#125;else &#123; return -1; &#125;&#125;)//利用箭頭函數與三元運算式的簡寫：const sortedBands = bands.sort((a, b) =&gt; (strip(a) &gt; strip(b)) ? 1 : -1); Step3. 把排序完的渲染到HTML中使用map與join來組成&lt;li&gt;元素放置12document.querySelector('#bands').innerHTML = sortedBands.map(band =&gt; `&lt;li&gt;$&#123;band&#125;&lt;/li&gt;`).join(''); 使用join(‘’)修改連結符號為空白, 否則原先陣列的分隔符號是,也會一併渲染在html中。 其他這篇相對比較簡單一些，運用到都是之前有練習過的語法:D]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」16 - Mouse Move Shadow]]></title>
    <url>%2F2017%2F10%2FJavaScript30-16-Mouse-Move-Shadow%2F</url>
    <content type="text"><![CDATA[主題透過textShadow讓文字的陰影隨滑鼠位置偏移，並稍微帶到ES6的解構賦值的用法。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 設定目標區域與基本偏移量 抓取HTML中的hero與text做為目標區域 設定基本偏移基準walk = 100 Step2. 建立觸發條件與事件 設定hero.addEventListener(&#39;mousemove&#39;, shadow) 觸發事件備註：1234567891011121314151617181920212223function shadow(e) &#123; // 透過解構賦值取得並設定資訊 const &#123; offsetHeight: height, offsetWidth: width &#125; = hero; let &#123; offsetX: x, offsetY: y &#125; = e; // 如果在目標區域外，則在加上目標座標值 if (this !== e.target) &#123; x = x + e.target.offsetLeft; y = y + e.target.offsetTop; &#125; // 四捨五入最終偏移值 const xWalk = Math.round((x / width * walk) - (walk/2)); const yWalk = Math.round((y / height * walk) - (walk/2)); console.log(xWalk, yWalk); // 使用textShadow來設定文字陰影 text.style.textShadow = ` $&#123;xWalk&#125;px $&#123;yWalk&#125;px 0px rgba(0, 0, 0, 0.5), $&#123;xWalk * -1&#125;px $&#123;yWalk&#125;px 0px rgba(0, 0, 0, 0.5), $&#123;yWalk&#125;px $&#123;xWalk * -1&#125;px 0px rgba(0, 0, 0, 0.5), $&#123;yWalk * -1&#125;px $&#123;xWalk&#125;px 0px rgba(0, 0, 0, 0.5) `&#125; Javascript語法&amp;備註解構賦值(Destructuring assignment)透過解構賦值，可以把直接把物件/陣列中的值塞入變數中，擷取一小段程式碼做說明：1234// 下面這段等同於 const height = hero.offsetHeight;const &#123; offsetHeight: height &#125; = hero;// 下面這段等同於 let x = e.offsetX;let &#123; offsetX: x &#125; = e; 參閱:MDN-Destructuring assignment關於解構賦值對我來說目前還是需要很用力的去閱讀才能讀懂，雖然可以簡寫並縮短不少程式碼，但使用上滿不直覺的，所以我自己目前還是會用舊的賦值寫法多，努力中。 Math.round可以將內容的數值進行四捨五入的動作。 參閱:MDN-Math.round() CSS語法備註12/* offset-x | offset-y | blur-radius | color */text-shadow: 1px 1px 2px black; 參閱:MDN-text-shadow]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Vue.js + Firebase 製作即時聊天功能(2) - storage]]></title>
    <url>%2F2017%2F09%2Fvue-firebase-realtime-line-chat-2-storage%2F</url>
    <content type="text"><![CDATA[繼上次的練習用 Vue.js + Firebase 製作即時聊天功能，這次用firebase的storage來擴充傳圖片的功能！ &gt;DEMO&lt;&gt;原始碼-GitHub&lt;Firebase設定要先到左側選單找到storage，進去啟用後再回到首頁複製一次連結資訊。 要確定storage中已經有值喔！ 流程 點選傳送圖片 選取圖片/使用拍照功能 上傳到storage並顯示進度條 完成將帶回的圖片連結寫進db 透過realtime db更新，讓所有連線者即時看到圖片 刻畫面加個小按鈕，並且把圖片顯示框寫好，紀錄一下遇到的問題：當把input file隱藏起來後，一直無法套上pointer的效果，結果爬文後才發現要讓他有pointer的效果要加上padding-left:100%！1234567891011.roomBottom__tools_upload input &#123; width: 100%; height: 100%; left: 0; right: 0; opacity: 0; position: absolute; cursor: pointer; /* 讓input file可以支援pointer要加pl100% */ padding-left: 100%;&#125; 主程式僅列出更新的部分，其他同上一篇，一樣不包含落落長的CSS，完整參考github HTML:12345678910111213141516171819202122232425&lt;!-- ...略... --&gt; &lt;!-- 區塊：body 中的content(other&amp;self都更新了) --&gt; &lt;div class="messageBox__content"&gt; &lt;!-- 新增v-if判斷格式，依據不同的格式顯示不同樣式與內容 --&gt; &lt;div v-if="item.type == 'text'" class="messageBox__message"&gt;&#123;&#123;item.message&#125;&#125;&lt;/div&gt; &lt;div v-if="item.type == 'image'" class="messageBox__image"&gt;&lt;img :src="item.message"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 新區塊:上傳進度條 --&gt; &lt;!-- 使用v-show，當符合條件時才顯示（upload==ture) --&gt; &lt;div v-show="upload" class="messageBox messageBox--self"&gt; &lt;div class="messageBox__progress"&gt; &lt;div id="js-progressBar" class="messageBox__progress--state"&gt;&lt;/div&gt; &lt;div class="messageBox__progress--number"&gt;&#123;&#123;progress&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 區塊：bottom --&gt; &lt;div class="roomBottom__tools"&gt; &lt;div class="roomBottom__tools_upload"&gt; &lt;!-- 使用accept="image/*"讓手持裝置可選圖片來源(拍照/相本) --&gt; &lt;!-- 加入onchange事件：@change="sendImage($event)" --&gt; &lt;input type="file" accept="image/*" @change="sendImage($event)"&gt; &lt;img src="../assets/tools_file.png"&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- ...略... --&gt; JavaScript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 跟msgRef一樣先宣告好storage會用到的資料夾const storageRef = firebase.storage().ref('/images/');data() &#123; return &#123; // ..略 upload: false, // 用來判斷是否顯示進度條 progress: '' // 用來放進度條％數文字用 &#125;&#125;,methods: &#123; /** 傳送訊息 */ sendMessage(e) &#123; // ..略 msgRef.push(&#123; userName: userName.value, type: 'text', // 新增狀態，傳文字訊息是text message: message.value, timeStamp: vm.getTime() &#125;) &#125;, /** 傳送圖片 */ sendImage(e) &#123; const vm = this; const userName = document.querySelector('#js-userName'); // 取得上傳檔案的資料 const file = e.target.files[0]; const fileName = Math.floor(Date.now() / 1000) + `_$&#123;file.name&#125;`; const metadata = &#123; contentType: 'image/*' &#125;; // 取得HTML進度條元素 let progressBar = document.querySelector('#js-progressBar'); // 上傳資訊設定 const uploadTask = storageRef.child(fileName).put(file, metadata); // 上傳狀態處理 uploadTask.on(firebase.storage.TaskEvent.STATE_CHANGED, /* 上傳進度 */ function(snapshot) &#123; let progress = Math.floor((snapshot.bytesTransferred / snapshot.totalBytes) * 100); if(progress &lt; 100) &#123; // 開啟進度條 vm.upload = true; vm.progress = `$&#123;progress&#125;%`; progressBar.setAttribute('style',`width:$&#123;progress&#125;%`); &#125; &#125;, /* 錯誤處理 */ function(error) &#123; msgRef.child('bug/').push(&#123; userName: userName.value, type: 'image', message: error.code, timeStamp: vm.getTime() &#125;) &#125;, /* 上傳結束處理 */ function() &#123; var downloadURL = uploadTask.snapshot.downloadURL; msgRef.push(&#123; userName: userName.value, type: 'image', message: downloadURL, timeStamp: vm.getTime() &#125;) // 關閉進度條 vm.upload = false; &#125;); &#125;&#125; 有空的話再練習清單 加入拖曳傳圖功能 圖檔縮放框 心得firebase的storage提供的API可以很輕鬆的取回上傳進度、以及上傳後的網址回傳，普遍常見的訊息儲存與圖片上傳都可以透過firebase來實現無後端程式。 今天一起來就開始邊寫邊測，功能實現真的好興奮啊XD 然後我這樣components越寫越長好像很糟糕，我必須要趕快找正確拆分邏輯的作法了XD!]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Firebase</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Vue.js + Firebase 製作即時聊天功能]]></title>
    <url>%2F2017%2F09%2Fvue-firebase-realtime-line-chat%2F</url>
    <content type="text"><![CDATA[這幾天在練習用vue &amp; firebase刻一個仿line即時同步聊天的功能，直接初體驗vue.js + firebase + webpack三種願望一次滿足XD！ update: 20170923更新[用 Vue.js + Firebase 製作即時聊天功能(2) - storage](https://guahsu.io/2017/09/vue-firebase-realtime-line-chat-2-storage/) &gt;DEMO&lt;&gt;原始碼-GitHub&lt; 這幾天想到就會再稍微更新，GitHub與下方文章可能會略有不同 環境設定步驟 首先安裝node.js，理論目前的版本都會有內建npm了。 下載位置：https://nodejs.org可以透過node -v及npm -v來查證是否已安裝完成node與npm。 安裝vue-cli，透過指令npm install --g vue-cli安裝。 可以透過vue -V來查證是否已安裝完成(-V是大寫唷)。 Vue-cli &amp; webpack 先起一個資料夾來存放專案，並進入該資料夾內， 接著建立專案，透過vue-cli可以透過指令直接建立一包專案，這裡我們使用指令vue init webpack來建立webpack的專案包。 安裝vue-cli後，可以在命令列下vue list列出可用的template建立專案使用vue init &lt;template&gt;這次用到的是webpack。 建立設定項目:[]&lt;方框內的是我的設定選項 123456789? Generate project in current directory? //建於當前資料夾[Yes]? Project name (folder_name) //專案名稱，注意需小寫 [自訂專案名稱]? Project description A Vue.js project //專案描述 [自訂描述]? Author //作者，預設抓當前環境git user [自訂]? Vue build standalone [Enter]? Install vue-router? //安裝vue-router [Yes]? Use ESLint to lint your code? [No]? Setup unit tests with Karma + Mocha? [No]? Setup e2e tests with Nightwatch? [No] 當環境建立好後，輸入指令npm install使相依套件都下載到當前專案中 主要目錄結構：12345678910|- build (webpack的設定檔)|- config (專案設定檔)|- dist (編譯後產出的位置)|- src (專案程式碼目錄) |- assets (其他 css, js, images) |- components (主要 vue 元件) |- router (vue 的路由器) |- App.vue (主要樣版檔) |- main.js (vue js 主檔案)|- index.js 靜態首頁(進入點) Firebase 建立一個專案 將Firebase的連結資訊複製起來 進入Database 修改權限並發布 vue-router設定 到index.html把firebase剛才複製的那串載入至head中 到router/index.js修改程式:vue-router是vue的路由器，備註內部使用方式如下：12345678910111213141516171819import Vue from 'vue'import Router from 'vue-router'//載入元件ChatRoomimport ChatRoom from '@/components/ChatRoom'Vue.use(Router)export default new Router(&#123; routes: [ &#123; //路徑用於網址列 path: '/', //name用於設定連結，例如樣板頁中可用下面方式來寫連結，就不用寫&lt;a&gt;掛path了 //&lt;router-link :to="&#123; name: 'ChatRoom' &#125;&gt;ChatRoom Page&lt;/router-link&gt; name: 'ChatRoom', //到這個ChatRoom(/)時，使用ChatRoom元件 component: ChatRoom &#125; ]&#125;) 而routes內是陣列包覆物件，所以要再新增一個就只要透過逗號(,)的物件新增方式即可，而router的結果都會被呈現在&lt;router-view&gt;&lt;/router-view&gt;中(參考main.js)。 在我的程式碼中，Hello已被替換為ChatRoom(預設範例為Hello)其實這個練習中目前並沒有實際用到router的功能，因為僅載入一頁XD。詳細設定可參閱官方文件vue-router 2官方文件 流程 輸入使用者名稱後才能發文 然後自己的發文是綠底，其他人是灰色(跟line一樣) 就這樣XD (傳圖功能請參考第二篇-&gt;用 Vue.js + Firebase 製作即時聊天功能(2) - storage) 主程式撰寫ChatRoom 到components/ChatRoom.vue(預設是Hello.vue我改名了) HTML與JS都有用到vue的寫法，我將撰寫的程式已備註如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;template&gt; &lt;div class="container"&gt; &lt;!-- 區塊：name area --&gt; &lt;div class="name"&gt; &lt;h3&gt;Name：&#123;&#123; userName &#125;&#125;&lt;/h3&gt; &lt;!-- 註解：使用@click來偵測click，觸發時執行method中的setName() --&gt; &lt;div class="reset" @click="setName()"&gt;Reset Name&lt;/div&gt; &lt;/div&gt; &lt;!-- 區塊：chat room --&gt; &lt;div class="chatRoom"&gt; &lt;!-- 區塊：head --&gt; &lt;div class="roomHead"&gt; &lt;div class="roomHead__topButtons"&gt; &lt;div class="roomHead__button close"&gt;&lt;/div&gt; &lt;div class="roomHead__button minimize"&gt;&lt;/div&gt; &lt;div class="roomHead__button zoom"&gt;&lt;/div&gt; &lt;/div&gt; &lt;img src="https://lorempixel.com/50/50/" class="roomHead__img" draggable="false"&gt; &lt;div class="roomHead__title"&gt;Test Room&lt;/div&gt; &lt;/div&gt; &lt;!-- 區塊：body --&gt; &lt;div id="js-roomBody" class="roomBody"&gt; &lt;!-- 註解：使用template來當迴圈容器，或是判斷用的容器，當條件達成時產出template內容 --&gt; &lt;template v-for="item in messages"&gt; &lt;!-- other people --&gt; &lt;template v-if="item.userName != userName"&gt; &lt;div class="messageBox"&gt; &lt;img src="https://lorempixel.com/40/40/" class="messageBox__img" draggable="false"&gt; &lt;div class="messageBox__content"&gt; &lt;!-- 註解：Vue使用雙花括號&#123;&#123;&#125;&#125;來顯示script中data:的資料 --&gt; &lt;div class="messageBox__name"&gt;&#123;&#123;item.userName&#125;&#125;&lt;/div&gt; &lt;div class="messageBox__text"&gt;&#123;&#123;item.message&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class="messageBox__time"&gt;&#123;&#123;item.timeStamp&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;!-- 區塊：self --&gt; &lt;template v-if="item.userName == userName"&gt; &lt;div class="messageBox messageBox--self"&gt; &lt;div class="messageBox__time messageBox__time--self"&gt;&#123;&#123;item.timeStamp&#125;&#125;&lt;/div&gt; &lt;div class="messageBox__content messageBox__content--self"&gt; &lt;div class="messageBox__text messageBox__text--self"&gt;&#123;&#123;item.message&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;/template&gt; &lt;/div&gt; &lt;!-- 區塊：bottom --&gt; &lt;!-- 註解：使用:class來寫class是否顯示的判斷式&#123; class: 判斷式 &#125; --&gt; &lt;div class="roomBottom" :class="&#123; disable: !userName &#125;"&gt; &lt;div class="roomBottom__tools"&gt;&lt;/div&gt; &lt;div class="roomBottom__input"&gt; &lt;!-- 若要再帶入原生js的event(e)到function中，必須使用$event當參數傳入 --&gt; &lt;textarea id="js-message" class="roomBottom__input__textarea" :class="&#123; disable: !userName &#125;" @keydown.enter="sendMessage($event)"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 區塊：modal --&gt; &lt;div id="js-modal" class="modal"&gt; &lt;div class="modal__container"&gt; &lt;header class="modal__header"&gt; &lt;h2 class="view-title"&gt;輸入名稱&lt;/h2&gt; &lt;/header&gt; &lt;div class="modal__body"&gt; &lt;!-- 註解：使用@keydown.enter來偵測keydown enter，觸發時執行method中的saveName() --&gt; &lt;input type="text" id="js-userName" class="userName" maxlength="6" @keydown.enter.="saveName()"&gt; &lt;div class="button" @click="saveName()"&gt;設定&lt;/div&gt; &lt;/div&gt; &lt;footer class="modal__footer"&gt;&lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// msgRef = firebase中的資料表/messages/，若沒有的會自動建立const msgRef = firebase.database().ref('/messages/');export default &#123; // 指定此頁使用的name name: 'ChatRoom', // 資料位置，於html中可用&#123;&#123;&#125;&#125;渲染出來 data() &#123; return &#123; userName: '', messages: [] &#125; &#125;, // 這個頁面的functions methods: &#123; /** 彈出設定視窗 */ setName() &#123; document.querySelector('#js-modal').style.display = 'block'; &#125;, /** 儲存設定名稱 */ saveName() &#123; // vue的mtthod中this是指export中這整塊的資料 const vm = this; const userName = document.querySelector('#js-userName').value; if (userName.trim() == '') &#123; return; &#125; // 這裡的vm.userName(this.userName)就是data()裡面的userName vm.userName = userName; document.querySelector('#js-modal').style.display = 'none'; &#125;, /** 取得時間 */ getTime() &#123; const now = new Date(); const hours = now.getHours(); const minutes = now.getMinutes(); const format = (hours &gt;= 12) ? "下午" : "上午"; return `$&#123;format&#125; $&#123;hours&#125;:$&#123;minutes&#125;`; &#125;, /** 傳送訊息 */ sendMessage(e) &#123; const vm = this; let userName = document.querySelector('#js-userName'); let message = document.querySelector('#js-message'); // 如果是按住shift則不傳送訊息(多行輸入) if (e.shiftKey) &#123; return false; &#125; // 如果輸入是空則不傳送訊息 if(message.value.length &lt;=1 &amp;&amp; message.value.trim() == '') &#123; // 避免enter產生的空白換行 e.preventDefault(); return false; &#125; // 對firebase的db做push，db只能接受json物件格式，若要用陣列要先轉字串來存 msgRef.push(&#123; userName: userName.value, message: message.value, // 取得時間，這裡的vm.getTime()就是method中的getTime timeStamp: vm.getTime() &#125;) // 清空輸入欄位並避免enter產生的空白換行 message.value = ''; e.preventDefault(); &#125; &#125;, // mounted是vue的生命週期之一，代表模板已編譯完成，已經取值準備渲染HTML畫面了 mounted() &#123; const vm = this; msgRef.on('value', function(snapshot) &#123; const val = snapshot.val(); vm.messages = val; &#125;) &#125;, // update是vue的生命週期之一，接再munted後方代表HTML元件渲染完成後 updated() &#123; // 當畫面渲染完成，把聊天視窗滾到最底部(讀取最新消息) const roomBody = document.querySelector('#js-roomBody'); roomBody.scrollTop = roomBody.scrollHeight; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;/* CSS太多，不占版面放於github供參考 */&lt;/style&gt; 執行與編譯 使用指令npm run dev來讓這專案在本機掛server起來(預設8080port)，之後每次調整檔案內容，網頁就會自動刷新，非常方便開發及測試:D! 編譯使用npm run build會將src中所撰寫的資訊都壓縮至dist資料夾內。 稍微備註，編譯後的index在載入js/css時的路徑有多一個.，會導致放靜態主機時讀取錯誤(因為其實是在同一層)，所以可以到config/index.js中將設定調整為assetsPublicPat = &#39;&#39;來解決 心得目前還有卡著JS30尚未練習及寫完心得，但看著各路大神分享的資源，就一直很想寫看看XDvue-cli &amp; firebase &amp; webpack都是第一次使用，這個練習後，對這三神器終於有很基礎的理解了。 vue.js我最初會想學習vue是因為有中文文件(遮臉)，以及方便載入(可以直接掛載一個vue.js在html中來使用，像jQuery一樣)，目前這專案我學習到的是HTML中的template及v-if/v-for，以及on(@),bind(:)的用法，很方便可以組織動態的前端邏輯，而不用在js中組大量的字串模板。 在js控制中，我覺得生命周期的設定很棒，可以很方便且”清楚”的在預想的狀況中設定應該出現的效果，例如整個渲染完成前可以掛一個加載的效果等等.. 但這小練習我都把邏輯整在同一個vue中，還未學到/使用在vue中正確拆分邏輯的做法。 Firebase之前有稍微聽過被google合併，但就僅此於而已此從未使用及了解過XD這次練習中使用到的database覺得很新奇阿，是一個雲端即時同步的noSQL，設定非常簡單方便，也是第一次親身寫出/感受到websoket的效果感(超酷)。其他相關的功能也很多，之後有機會一定要在多研究一下(越來越多待讀項目..) Webpack一直有聽到，看過，但從未使用過，但其實這次使用後的算是知道如何使用，但不了解內容，對於設定檔目前沒有細讀，並不是很熟悉各相關設定檔，反而覺得最特別的是熱加載及編譯後的程式碼壓縮混淆!但日後練習都用webpack起，遇到問題找解答，應該會越來越熟吧XD 感謝六角學院放出的Vue教學系列，從幼幼班入門到vue-cli &amp; firebase介紹，讓我能從零學習相關知識，從而建立完這個練習:) 六角學院在本週日也要釋放Bootstrap的課程了！但不知何時才有空可以把全系列看過並實作完啊QQ…. 六角學院-FB洧杰老師-FB卡斯伯老師-FB]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Firebase</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」15 - LocalStorage]]></title>
    <url>%2F2017%2F09%2FJavaScript30-15-LocalStorage%2F</url>
    <content type="text"><![CDATA[主題這篇介紹LocalStorage的用法，透過一個小菜單來透過localstorage做資料增刪功能。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 基礎設定作者已經設定好這篇練習用的html與css，主要的架構由一個div包著ul與from，類似Todo-List的清單(ul)與輸入欄位(form)。 Step2. 撰寫輸入欄位新增功能首先取得form元素及ul，並宣告一個空陣列來存放新增資料。123const addItems = document.querySelector('.add-items');const itemsList = document.querySelector('.plates');const items = []; 接著撰寫一個addItem，參照備註:1234567891011121314151617function addItem(e) &#123; // 加上preventDefault()避免每次submit都會重整網頁 e.preventDefault(); // 利用再次querySelector來選取form中的input欄位值 const text = this.querySelector('[name=item]').value; // 宣告新增要存入的物件，是輸入的文字與是否勾選的狀態(done) const item = &#123; text, done: false &#125; console.log(item); // 清空輸入欄位 this.reset();&#125;// 監聽submit按鈕addItems.addEventListener('submit', addItem); 這樣每次submit後items就會新增在輸入欄位中的物件了！可透過console.log來查看新增的物件狀態。 Step3. 顯示新增的清單在上一個步驟中所做的只有存於宣告的陣列中，並沒有抓出來顯示在HTML中，所以要寫一個function來顯示：123456789101112// ES6可在function中的參數直接設定參數預設值function populateList(plates = [], platesList) &#123; // 使用map搭配join來組成字串，並顯示在html的清單ul中 platesList.innerHTML = plates.map((plate, i) =&gt; &#123; return ` &lt;li&gt; &lt;input type="checkbox" data-index=$&#123;i&#125; id="item$&#123;i&#125;" $&#123;plate.done ? 'checked' : ''&#125;/&gt; &lt;label for="item$&#123;i&#125;"&gt;$&#123;plate.text&#125;&lt;/label&gt; &lt;/li&gt; `; &#125;).join('');&#125; 然後要記得回到addItem中把platesList放在items.push(item)後面，讓每次輸入送出後都會執行這個function重新列出組成的物件字串。 Step4. 加入LocalStorage當完成了新增功能後，就要進入主軸LocalStorage了，這可以讓瀏覽器存取你設定在這個頁面的資訊，所以首先在addItem中修改加入這段：1234567function addItem(e) &#123;//...略 populateList(items, itemsList); localStorage.setItem('items', JSON.stringify(items)); this.reset();//...略&#125; 這裡將items的資訊存在localStorage中一個叫做items的自訂物件中，注意的是存入的物件或陣列必須透過JSON.stringify轉為字串，因為localStorage中的值是string，否則直接存只會得到”object object”的字串。 接著修改最一開始宣告的items:1const items = JSON.parse(localStorage.getItem('items')) || []; 讓頁面在重整後，先判斷localStorage中是否有存放items物件，沒有的話則給空陣列。 Step5. 儲存checkbox狀態這裡要新增一個functiontoggleDone並監聽itemsList的click動作，123456789101112131415function toggleDone(e) &#123; // 偵測進來的點擊是input(checkbox)才動作 if (!e.target.matches('input')) return; // 取得checkbox的data-index值 const el = e.target; const index = el.dataset.index; // 利用！來使done的狀態在true/false間切換 items[index].done = !items[index].done; // 將更新後的狀態寫入localStorage中 localStorage.setItem('items', JSON.stringify(items)); // 更新列表 populateList(items, itemsList);&#125;// 監聽clickitemsList.addEventListener('click', toggleDone); Step6. 增加刪除功能到目前為止只有新增跟儲存的功能，來增加一個刪除按鈕吧，首先在populateList中字串組成中改成這樣：1234567` &lt;li&gt; &lt;input type="checkbox" data-index=$&#123;i&#125; id="item$&#123;i&#125;" $&#123;plate.done ? 'checked' : ''&#125;/&gt; &lt;label for="item$&#123;i&#125;"&gt;$&#123;plate.text&#125;&lt;/label&gt; &lt;span data-index=$&#123;i&#125;&gt;delete&lt;span&gt; &lt;/li&gt;` 這會使每次輸出時多一個delete的文字在後方，然後調整toggleDone：12345678910111213141516171819202122function toggleDone(e) &#123; // 初始化一個存檔狀態 let save = false; // 取得觸發元素的data-index值 const el = e.target; const index = el.dataset.index; // 判斷觸發元素，如果是input則為checkbox的狀態切換 if(e.target.matches('input'))&#123; items[index].done = !items[index].done; save = true; &#125; // 如果是span則是透過splice刪除該物件 if(e.target.matches('span'))&#123; items.splice(index, 1); save = true; &#125; // 判斷上方有做事才存擋 if(save)&#123; localStorage.setItem('items', JSON.stringify(items)); populateList(items, itemsList); &#125;&#125; Step7. 新增全選/全取消功能在HTML的form元素後方加上這段HTML CODE:12345678910111213&lt;style&gt;.checkMethod &#123; padding: 0; text-align: left; list-style: none;&#125;&lt;/style&gt;&lt;ul class="checkMethod"&gt; &lt;li&gt; &lt;input class="checkAll" type="checkbox"&gt; &lt;label&gt;Check All&lt;/label&gt; &lt;/li&gt;&lt;/ul&gt; 使其有多一個checkbox來操作全選/全取消，接著撰寫對應的功能：1234567891011121314151617// 取得操作元素const checkAllBtn = document.querySelector('.checkAll');// 全選/全取消const checkAll = function(e) &#123; // 取得觸發當下全選按鈕是否已勾選 const checkStatus = e.target.checked; // 透過迴圈將每個item的checkbox狀態改為與全選checobox狀態相同 items.forEach(index =&gt; &#123; index.done = checkStatus; &#125;); // 存檔 localStorage.setItem('items', JSON.stringify(items)); // 重整 populateList(items, itemsList);&#125;// 監聽操作元素動作checkAllBtn.addEventListener('click', checkAll); 探索本次探索就是Step6的刪除及Step7的新增全選/全取消功能功能擴充，基本上所有語法都是之前有使用及寫下過的，LocalStorage很實用，之前做的兩個小練習也都有使用上： JavaScript練習-臺北市旅遊景點 JavaScript-ETH-Linstener 其他終於JS30系列完成一半了，當初的目標就是把這系列先練習完，並強迫自己每篇都要擴充或調整原有功能並記錄心得，很多東西真的是在寫心得時會有重新領悟並加深印象的感覺:)。]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」14 - JavaScript References VS Copying]]></title>
    <url>%2F2017%2F08%2FJavaScript30-14-JavaScript-References-VS-Copying%2F</url>
    <content type="text"><![CDATA[主題介紹JavaScript中陣列與物件的引用(refrence)及複製(Copying)。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 原始型別JavaScript中的原始型別(Primitive Type)： String Number Boolean Null Undefine Step2. 物件型別JavaScript中的物件型別(Object Type)： 使用者自訂的物件 - var obj = {} 內建的物件型別 - Array, Date, Math, RegExp ..對，Array也是個物件。 12345678910// JS的陣列中可以使用物件的字串用法var arr = ['a', 'b', 'c'];console.log(arr[0]); // 'a'console.log(arr['0']); // 'a'// JS的陣列也可以塞屬性arr.test = function() &#123; return 'Hi'; &#125;;arr.test(); // 'Hi'typeof(arr); // 'object' Step3. Call by value原始型別都是Call by value，當複製時不影響彼此，如以下範例（上述個原始型別皆是）：12345var a = 'a';var b = a;console.log(a, b); // a ab = 'b';console.log(a, b); // a b 最初的b = a使b指向與a同一個記憶體位置(存放字串a)，而當b = &#39;b&#39;時，b建立了一個記憶體位置存放字串b，並指向該位置。 Step4. Call by refrence當物件型別被複製使用時，是會被彼此改變的如以下範例：12345678910111213// Arrayvar arr = ['a', 'b'];var arr2 = arr;console.log(arr, arr2);// ['a', 'b'] ['a', 'b']arr2[1] = 'c';console.log(arr, arr2);// ['a', 'c'] ['a', 'c']// Objectvar obj = &#123; a: 1, b: 2 &#125;;var obj2 = obj;console.log(obj, obj2);// &#123; a: 1, b: 2 &#125; &#123; a: 1, b: 2 &#125;obj2.b = 3;console.log(obj, obj2);// &#123; a: 1, b: 3 &#125; &#123; a: 1, b: 3 &#125; 以陣列為例，當最初的arr2 = arr時，arr2指向與arr同個記憶體位置(存放陣列[‘a’, ‘b’])，但在arr2[1] = &#39;c&#39;時，arr2仍指著與arr同個位置，所以當改變了索引[1]的值時，arr及arr2的索引[1]都被變更了。 Step5. 陣列的複製為了避免Call by refrence時會去異動到原本的陣列，就要先把原本的陣列做一次複製，用剛才的範例來做，有以下幾種方法：Array.prototype.Slice()如果直接使用slice()不指定起始與結束位置的話，就等於直接複製整個整列：12345var arr = ['a', 'b'];var arr2 = arr.slice();console.log(arr, arr2);// ['a', 'b'] ['a', 'b']arr2[1] = 'c';console.log(arr, arr2);// ['a', 'b'] ['a', 'c'] 參閱：MDN-Array.prototype.slice() Array.prototype.concat()使用concat()可以合併陣列，所以如果使用空陣列來合併原陣列，也會達到複製整個陣列的效果：12345var arr = ['a', 'b'];var arr2 = [].concat(arr);console.log(arr, arr2);// ['a', 'b'] ['a', 'b']arr2[1] = 'c';console.log(arr, arr2);// ['a', 'b'] ['a', 'c'] 參閱：MDN-Array.prototype.concat() Spread syntaxES6的Spread語法，直接使用於複製方法如下：12345var arr = ['a', 'b'];var arr2 = [...arr];console.log(arr, arr2);// ['a', 'b'] ['a', 'b']arr2[1] = 'c';console.log(arr, arr2);// ['a', 'b'] ['a', 'c'] 參閱：MDN-Spread syntax Array.from()同為ES6的Array.from()也可以快速達到複製的效果： 12345var arr = ['a', 'b'];var arr2 = Array.from(arr);console.log(arr, arr2);// ['a', 'b'] ['a', 'b']arr2[1] = 'c';console.log(arr, arr2);// ['a', 'b'] ['a', 'c'] 參閱：MDN-Array.from() Step6 物件的複製同樣的，物件也會有call by refrence的特性，所以與陣列相同，使用之前的範例來做物件的複製： Object.assign()使用Object.assign()來做，指定一個空的物件並把目標對象塞進去就好了：12345var obj = &#123; a: 1, b: 2 &#125;;var obj2 = Object.assign(&#123;&#125;, obj);console.log(obj, obj2);// &#123; a: 1, b: 2 &#125; &#123; a: 1, b: 2 &#125;obj2.b = 3;console.log(obj, obj2);// &#123; a: 1, b: 3 &#125; &#123; a: 1, b: 3 &#125; 參閱：MDN-Object.assign() Step7. JSON.parse * JSON.stringify利用JSON.parse * JSON.stringify來把目標對象作轉換賦值的動作，不論目標對象是什麼型別，都可以用這招來做複製：12345678910111213//Arrayvar arr = ['a', 'b'];var arr2 = JSON.parse(JSON.stringify(arr));console.log(arr, arr2);// ['a', 'b'] ['a', 'b']arr2[1] = 'c';console.log(arr, arr2);// ['a', 'b'] ['a', 'c']//Objectvar obj = &#123; a: 1, b: 2 &#125;;var obj2 = JSON.parse(JSON.stringify(obj));console.log(obj, obj2);// &#123; a: 1, b: 2 &#125; &#123; a: 1, b: 2 &#125;obj2.b = 3;console.log(obj, obj2);// &#123; a: 1, b: 3 &#125; &#123; a: 1, b: 3 &#125;]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」13 - Slide in on Scroll]]></title>
    <url>%2F2017%2F08%2FJavaScript30-13-Slide-in-on-Scroll%2F</url>
    <content type="text"><![CDATA[主題這篇介紹當滾動視窗到定點時動畫滑入圖片的效果，而我在這裡替圖片增加了簡易的lazy load效果。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 基礎設定作者已經在所有的圖片中加入了待會會用到的class : align-right / align-left : 滑入效果用（左/右） slide-in : JavaScript抓取用並已經將相關的動畫滑入效果寫好。 Step2. 建立觸發條件,並監聽滾動事件目的是使滾動視窗到定點時顯示效果，所以要監聽的是整個視窗，用window，事件選用scroll，但是如果單純使用scroll來操作的話，每次的畫面滾動都會有大量事件被觸發，會對效能上造成影響，所以作者多寫了一個debounce來使觸發間隔為20毫秒以上：1234567891011121314function debounce(func, wait = 20, immediate = true) &#123; var timeout; return function () &#123; var context = this, args = arguments; var later = function () &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125; 所以監聽事件就會寫成window.addEventListener(&#39;scroll&#39;, debounce(checkSlide));。 Step3. 設定觸發後的事件內容在一開始先取得所有.slide-in的圖片元素，使用querySelectorAll，1const sliderImages = document.querySelectorAll('.slide-in'); 接著編寫每次scroll處發的checkSlide function:123456789101112131415161718function checkSlide() &#123; sliderImages.forEach(sliderImage =&gt; &#123; // 取得圖片1/2高度的定位點（卷軸垂直位移量＋視窗高度）- 1/2圖片高度 const slideInAt = (window.scrollY + window.innerHeight) - (sliderImage.height / 2); // 取得圖片底部定位點（利用圖片頂部定位點+圖片高度取得） const imageBottom = sliderImage.offsetTop + sliderImage.height; // 判斷視窗是否已經超過圖片高度一半 const isHalfShown = slideInAt &gt; sliderImage.offsetTop; // 判斷滾動範圍是否已經超過圖片底部（卷軸垂直位移量） const isNotScrolledPast = window.scrollY &lt; imageBottom; // 判斷是否超過圖片一半高，且視窗尚未超過圖片底部來增加或移除css效果 if (isHalfShown &amp;&amp; isNotScrolledPast) &#123; sliderImage.classList.add('active'); &#125; else &#123; sliderImage.classList.remove('active'); &#125; &#125;);&#125; 探索學會了抓取視窗高度並當滾動至對應位置時載入/移除動畫效果，就想來試試看增加一個功能，當到對應位置時，才去做圖片的載入及動畫效果，就是lazyload的很簡易版應用，套用在這個練習上。 首先先把每個圖片改為用data-imglink來放圖片連結，像是這樣1&lt;img src="" data-imglink="http://unsplash.it/400/401" class="align-right slide-in"&gt; 接著來修改觸發的事件內容，因為原本的寫法只要重新讀到圖片1/2位置就會觸發，我要做的只要第一次觸發效果就好，且是在讀取圖片頂端時觸發，所以修改如下，新增的用備註註明：12345678910111213141516171819function checkSlide(e) &#123; sliderImages.forEach(sliderImage =&gt; &#123; // 取得圖片的定位點 const slideInAt = (window.scrollY + window.innerHeight) - (sliderImage.height); // 判斷是否滾動到圖片的頂端 const isImgTop = slideInAt &gt; sliderImage.offsetTop; if (isImgTop) &#123; // 透過dataset取得html裡面的data-imglink連結 const imageLink = sliderImage.dataset.imglink; // 用setAttribute來設置取得的連結 sliderImage.setAttribute('src', imageLink); // 增加一個事件，當圖片載入完成後套用css的動畫效果 sliderImage.addEventListener('load', () =&gt; &#123; sliderImage.classList.add('active'); &#125;); &#125; &#125;)&#125; JavaScript語法備註Window.scrollY目前瀏覽器視窗已滾動的Y軸（垂直位置） 參閱：MDN-Window.scrollY Window.innerHeight目前瀏覽器視窗的高度 參閱：MDN-Window.innerHeight HTMLElement.offsetTop返回指定元素相對於有父元素(offsetParent)中的頂端位置，以此練習來說，sliderImage的父元素就是window。 參閱：MDN-Window.innerHeight HTMLElement.dataset透過dataset可以取回在HTML中設置的data-*內容，注意使用dataset時property不用再將加上data-開頭，例如：1&lt;div class="test" data-greet="hi"&gt;&lt;/div&gt; 1document.querySelector('.test').dataset.greet; // hi 參閱：MDN-HTMLElement.dataset]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」12 - Key Sequence Detection]]></title>
    <url>%2F2017%2F07%2FJavaScript30-12-Key-Sequence-Detection%2F</url>
    <content type="text"><![CDATA[主題記得以前玩遊戲常輸入的祕技嗎？上上下下左右左右BA之類的，現在很多網站也有偷塞一些密碼，當你輸入完後會出現對應特效，這篇就是介紹如何用JS來做這樣的小效果。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 設定目標在這個效果中，目的是在瀏覽器內容中透過鍵盤觸發對應的“密碼”後執行，所以需要設定一個陣列來保存輸入值，並設定好設定的密碼(我設定為guahsu)，接著針對window對這個瀏覽器視窗來做addEventListener(&#39;keyup&#39;..)監聽鍵盤動作。 Step2. 執行當觸發keyup時利用陣列的push()來塞入鍵盤動作所觸發的輸入內容e.key，接著用陣列的splice()來控制密碼陣列，使其不超出密碼長度且堆疊替換掉第一個元素，最後透過陣列的join()及字串的includes()來驗證輸入內容是否與設定密碼相同。 程式備註12345678910111213141516const pressed = []; //保存輸入值用的陣列const secretCode = 'guahsu'; //設定的密碼//監聽整個瀏覽器視窗的鍵盤動作window.addEventListener('keyup', (e) =&gt; &#123; //push觸發的鍵盤輸入值到陣列中 pressed.push(e.key); //透過運算使pressed陣列長度始終與設定密碼相同，且當超出時替換掉陣列第一個元素 pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length); //判斷輸入值陣列的內容是否與設定密碼相同 if (pressed.join('').includes(secretCode)) &#123; //觸發效果 cornify_add(); &#125; //在畫面中顯示輸入內容 document.querySelector('.inputCode').innerHTML = pressed.join('-');&#125;) JavaScript語法&amp;備註Array.prototype.splice()splice(start, deleteCount, item1, item2, ...)可以對陣列內容過行刪除或新增第一個參數start為開始位置，若為負值則會返著數（由陣列尾部開始數），第二個參數deleteCount為移除數量，若為0則不移除、若為負值則沒反應，第三個參數item1..開始的為加入元素，可從第一個參數位置開始塞陣列元素。例如12345var arr = [1,2,3];arr.splice(0, 1); //代表從位置0開始刪除1個元素，arr變成[2,3]arr.splice(-1, 1); //代表從陣列尾巴第一個開始刪除1個元素，arr變成[1,2]arr.splice(0, -1); //第二個參數不接受複數，arr不變arr.splice(0, 1, '4') //從位置0刪除1個元素，並從位置0塞入'4'，arr變成['4',2,3] 所以回到練習中的這段code，就會了解為何這樣可以維持陣列長度並堆疊替換第一個元素1234const pressed = []; const secretCode = 'guahsu'pressed.push(e.key);pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length); 以此範例來說，第一個參數始終會是-7，第二個參數會是當前輸入陣列長度-6，所以當事件觸發到第七個陣列值（第七個輸入被觸發且push進pressed時），例如[1,2,3,4,5,6,7]時會變成pressed.splice(-7,1)，等於刪除倒數第七個元素（也就是index0第一筆），並透過陣列長度-設定密碼長度來決定刪除數量，使其維持在固定長度，之後每次的push會加在尾段，而splice會刪除第一個元素。 其實有卡住一點點，因為作者寫的第一個參數用-secretCode.length - 1，我一直搞不清楚跟用0有什麼差別囧 參閱：MDN-Array.prototype.splice() Array.prototype.join()用join()可以把陣列轉為字串，並透過參數設定連接符號。例如：123var arr = [1,2,3];arr.join(''); // '123'arr.join('@@'); // '1@@2@@3' 參閱：Array.prototype.join() Array.prototype.includes()在string跟array都有includes()可以使用，都是去判斷string/array是否包含incudes設定的參數後回傳true/false在這個練習中，因為使用pressed.join(&#39;&#39;).includes(secretCode);依據處理優先序在pressed.join()時已經被轉字串了，所以這裡的incudes()是屬於string的。 參閱：Array.prototype.includes() 探索這次雖然只是小小的效果，在寫心得的時候真的也是學到很多以前沒注意的東西，並在寫includes()才也知道string也有這個效果，以往我都只會使用match()，includes()屬於ES6的語法，爬文後整理到關於字串比對的使用還有以下各種方法：12345678910111213141516171819202122232425var str = 'abcde';var check1 = 'ab'; //包含ab，期待值是truevar check2 = 'ac'; //包含ac，期待值是false//用includes()來取得true/falsestr.includes(check1); //truestr.includes(check2); //false//用match()來處理，判斷是否為null來取得true/falsestr.match(check1); // objectstr.match(check2); // null//用indexOf()來處理，判斷是否為-1來取得true/falsestr.indexOf(check1); // 0str.indexOf(check2); // -1//用search()，判斷是否為-1來取得true/falsestr.search(check1); // 0str.search(check2); // -1//用RegExp正規表示式來取得true/falsevar reg1 = /ab/;var reg2 = /ac/;reg1.test(str); // truereg2.test(str); // false]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」11 - Custom Video Player]]></title>
    <url>%2F2017%2F07%2FJavaScript30-11-Custom-Video-Player%2F</url>
    <content type="text"><![CDATA[主題介紹如何使用HTML5的video tag來完成各種播放器功能，播放/暫停、快進/快退、音量控制、速率控制等… [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 基本設定作者已經有將基礎的css及html tag設定好，僅需針對各項目的功能開始進行js撰寫即可，但這邊我有將背景色調調整，並把對應icon改用font-awesome來顯示（原本是文字符號）。 由於寫到最後已經很多寫法跟原作者的方法不太一樣，所以接著各功能會再稍微備註為何這麼寫。 Step2. 播放/暫停按鈕為了在整個播放器範圍及點擊播放按鈕時能播放/暫停，先針對這兩個元素做addEventListener，並在togglePlay()中使影片產生對應動作＆更換圖示，比較特別的是使用了video[method]的寫法，來直接操作video的屬性，直接用影片是否已暫停paused來做判斷。123456789function togglePlay() &#123; const method = video.paused ? 'play' : 'pause'; const icon = video.paused ? `&lt;i class="icon-play"&gt;&lt;/i&gt;` : `&lt;i class="icon-pause"&gt;&lt;/i&gt;`; toggle.innerHTML = icon; video[method]();&#125;video.addEventListener('click', togglePlay);toggle.addEventListener('click', togglePlay); 原本是將圖標更換＆影片動作分開寫，我改成寫一起。 Step3. 音量/速率操作在HTML中已經定義好對應的input-range標籤，在這裡只需要做監聽並取屬性值來操作就好了！12&lt;input type="range" name="volume" class="player__slider" min="0" max="1" step="0.05" value="1"&gt;&lt;input type="range" name="playbackRate" class="player__slider" min="0.5" max="2" step="0.1" value="1"&gt;Ï 在javascript的部分，ranges是透過querySelectorAll來取得的，所以可以用forEach來把所有range加上addEventListener，也因為range是拖曳條，除了click外，也必須要監聽mousemove，而name的命名volume與playbackRate也就是video本身的屬性，直接使用。1234567function handleRangeUpadte() &#123; video[this.name] = this.value;&#125;ranges.forEach(range =&gt; &#123; range.addEventListener('change', handleRangeUpadte); range.addEventListener('mousemove', handleRangeUpadte);&#125;) Step4. 快進/快退操作一樣也在HTML中的input定義好對應的秒數了，只須取出使用。12&lt;button data-skip="-10" class="player__button skip_left"&gt;&lt;i class="icon-backward"&gt;&lt;/i&gt;&lt;/button&gt;&lt;button data-skip="25" class="player__button skip_right"&gt;&lt;i class="icon-forward"&gt;&lt;/i&gt;&lt;/button&gt; 在javascript的部分，原本的寫法只有點擊後觸發，因為我有加上鍵盤觸發的動作，所以將skip加上了一個參數direction來判斷，而skipButtons也跟Step3的ranges一樣用forEach來加上監聽效果，快進快退的作法是取出input中設定的data-skip後透過currentTime來調整影片時間。1234567891011121314function skip(direction) &#123; let skipTime = 0; if (direction === 'left') &#123; skipTime = document.querySelector('.skip_left').dataset.skip; &#125; else if (direction === 'right') &#123; skipTime = document.querySelector('.skip_right').dataset.skip; &#125; else &#123; skipTime = this.dataset.skip; &#125; video.currentTime += parseFloat(skipTime);&#125;skipButtons.forEach(button =&gt; &#123; button.addEventListener('click', skip);&#125;) Step5. 進度條顯示使用video的currenTime與duration計算出進度％數，再透過CSS改變進度條的色塊％數，值得一提的是作者有說到兩個監聽參數：timeupdate與progress都可以做為影片時間變動時的觸發條件，我稍微小測試後發現，使用progress會在載入時就將進度顯示在正確位置，而timeupdate必須在啟動播放後才會去抓到正確的位置，可以將CSS中的flexBasis預設設為50%來觀察這兩者的差別。12345function handleProgress() &#123; const precent = (video.currentTime / video.duration) * 100; progressBar.style.flexBasis = `$&#123;precent&#125;%`;&#125;video.addEventListener('progress', handleProgress); Step6 進度條操作在影片的進度條上，做點擊切換段落，或著是按著滑動片段，分解動作會有：點擊、按住並移動這兩種觸發條件，為了要讓function能同時判斷兩種狀態，必須要將其中一個條件設flag，這裡就將mousedown做了一個flag來操作狀態，並利用e.offsetX的位置及progress.offsetWidth寬度與影片總長來操作當前秒數。 監聽的部分，因為原本重複寫了四次addEventListener，所以我把會使用到的event寫在一個陣列裡面，使用forEach去執行。1234567891011121314let mousedown = false;function scrunb(e) &#123; const mouseType = e.type; if (mouseType === 'mousedown') &#123; mousedown = true; &#125; if (mouseType === 'mouseup') &#123; mousedown = false; &#125; if (mouseType === 'click' || mouseType === 'mousemove' &amp;&amp; mousedown) &#123; const scrunbTime = (e.offsetX / progress.offsetWidth) * video.duration; video.currentTime = scrunbTime; &#125;&#125;const progressEvents = ['click', 'mousemove', 'mousedown', 'mouseup'];progressEvents.forEach(progressEvent =&gt; &#123; progress.addEventListener(progressEvent, scrunb);&#125;) Step7. 全螢幕作者最後有提到的小功能，他說留給我們自己去研究。首先在HTML中加上對應的功能按鈕與圖標(就是這個放大圖標讓我去用font-aswsome的XD)1&lt;button class="player__button fullScreen" title="Full Screen"&gt;&lt;i class="icon-fullscreen"&gt;&lt;/i&gt;&lt;/button&gt; 然後再javascript中加入這段，多個判斷是為了不同的瀏覽器而寫，值得一提的是，不用對取消全螢幕特別做處理，預設就會有esc關閉及對應的關閉icon了，但如果有特別需求可以使用exitFullscreen()來關閉。123456789101112function fullScreen() &#123; if (video.requestFullscreen) &#123; video.requestFullscreen(); &#125; else if (video.msRequestFullscreen) &#123; video.msRequestFullscreen(); &#125; else if (video.mozRequestFullScreen) &#123; video.mozRequestFullScreen(); &#125; else if (video.webkitRequestFullscreen) &#123; video.webkitRequestFullscreen(); &#125;&#125;fullScreenBtn.addEventListener('click', fullScreen); Step8. 鍵盤動作偵測最後加上的功能是鍵盤對應操作，加入了空白對應播放/暫停、鍵盤左右鍵對應快進/快退，空白鍵加上了preventDefalut是防止預設空白會跳到最底下的功能。123456789101112131415161718function eventKeydown(e) &#123; switch (e.keyCode) &#123; //空白鍵 case 32: e.preventDefault() togglePlay(); break; //方向鍵左 case 37: skip('left'); break; //方向鍵右 case 39: skip('right') break; &#125;&#125;document.addEventListener('keydown', eventKeydown); HTML5語法&amp;備註Video &amp; Media Element這次的主軸是HTML的video標籤，所以滿多操作都是直接操作video的屬性，例如偵測暫停的paused或是當前播放時間currentTime，但其實這些屬性並非video獨有的，而是HTML Media Element，好比說audio也會有。 參閱：MDN-VideoMDN-HTMLMediaElement JavaScript語法&amp;備註屬性使用在Step2中有使用video[method]()的方法來操作屬性，其實相關的操作方法就等同於video.play()，但不能寫成video.method()，因為這樣就變成呼叫video底下的function method了，所以使用中括號[]包起來的會自動變成字串，可以避免掉這樣的問題。 HTMLElement.dataset在Step4中使用到的，使用dataset可以取得htmlTag中的data-*屬性！ 參閱：MDN- Event.preventDefault()在Step8中使用到的，這個方法是將取消事件（如果事件可取消），這次使用的場景是於網頁瀏覽器中按下空白，預設會將網頁捲到底部，但我希望只要啟動我的播放/暫停功能就好不要捲動，就可以使用。 參閱：MDN-Event.preventDefault() 探索本次的探索滿多，都已經寫在step中了，修改了播放器樣式及部分色調調整，對重複的監聽與變數整理，加入了全螢幕效果以及鍵盤操作功能。 其他終於踏出JavaScript30 2/3的第一步，最近好多事，一直沒能好好靜下心來進修，除了JS30，之前預購的一些CSS課程也要陸續上線了，稍微覺得時間有點不夠用外，也開始容易分心了XD，畢竟CSS等設計相關的課程看起來比較華麗啊哈哈哈。 加油持續把這系列練習完！！]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」10 - Hold Shift and Check Checkboxes]]></title>
    <url>%2F2017%2F07%2FJavaScript30-10-Hold-Shift-and-Check-Checkboxes%2F</url>
    <content type="text"><![CDATA[主題介紹如何使用Shift + 左鍵來完成連續區間選取，在這篇的探索中，我增加了連續區間取消選取及部分問題的改善。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1. 基本設定用querySelectorAll(&#39;.inbox input[type=&quot;checkbox&quot;]來把HTML中的checkbox選起來，並設置一個變數let lastChecked;作為稍後勾選位置的紀錄使用。 Step2. 觸發設定把所有選取的checkboxes使用forEach來加入addEventListener(&#39;click&#39;, handelCheck)。 Step3. handelCheck在這個function裡面，建立了一個區域變數let inBetween = false來當作選取區間的標記，並在每次觸發時檢查是否”有按著shift點擊”if(e.shiftKey &amp;&amp; this.checked)，若有的話則再跑一次forEach來透過inBetween對每個checkbox進行區間標記，把屬於區間內的checkbox勾起來，並記錄此次點擊的位置。 程式備註123456789101112131415161718192021222324//選取所有的checkboxconst checkboxes = document.querySelectorAll('.inbox input[type="checkbox"]');let lastChecked;function handleCheck(e) &#123; let inBetween = false; // 檢查是否按著shift點選 if (e.shiftKey &amp;&amp; this.checked) &#123; checkboxes.forEach(checkbox =&gt; &#123; // 當前點選的checkbox開始記錄到最後一個點選的checkbox關閉標記 if (checkbox === this || checkbox === lastChecked) &#123; inBetween = !inBetween; console.log('STarting to check them inbetween!'); &#125; // 勾選區間內為true的checkbox if (inBetween) &#123; checkbox.checked = true; &#125; &#125;); &#125; lastChecked = this;&#125;// 為每個checkbox加上click事件checkboxes.forEach(checkbox =&gt; checkbox.addEventListener('click', handleCheck)); 探索一開始做完原本作者講述的方法（也就是上面那段）的做法後，發現有些小問題，例如直接對著同一個checkbox點選會導致全選，也沒有辦法做區間取消選取的功能，所以重新寫了一個可以區間選取/取消的版本。 分析動作想一下會使用連續選取時，我自己的動作會有這幾種： 單選：單純的點一下進行勾選/取消 範圍選取：按住shift後點到其他checkbox 範圍取消：在2按住shift的狀態下，點到已勾選的checkbox 所以我依據這些動作分別寫了對應的功能。 程式備註1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 選取所有checkboxconst checkboxes = document.querySelectorAll('.inbox input[type="checkbox"]');let click; // 單純的點擊let selectClick; // 按下shift後的選取 let cancelClick; // 按下shift後的取消 const handleCheck = function (e) &#123; if (e.shiftKey &amp;&amp; this.checked) &#123; selectClick = this; selectBox(); &#125; else if (e.shiftKey &amp;&amp; !this.checked) &#123; cancelClick = this; cancleBox(); &#125; else if (this.checked) &#123; click = this; selectClick = undefined; cancelClick = undefined; &#125; else &#123; click = undefined; selectClick = undefined; cancelClick = undefined; &#125; // 選取功能 function selectBox() &#123; let inBetween = false; checkboxes.forEach(checkbox =&gt; &#123; // 將選取範圍內的checkbox加上標記 if (checkbox === selectClick || checkbox === click) &#123; inBetween = !inBetween; &#125; // 將有標記的checkbox勾選（且click不為undefined與selectClick是為了避免點自己全選） if (inBetween &amp;&amp; click !== undefined &amp;&amp; click !== selectClick) &#123; checkbox.checked = true; &#125; &#125;) &#125; //取消選取 function cancleBox(el) &#123; let inBetween = false; checkboxes.forEach(checkbox =&gt; &#123; // 將選取範圍內的checkbox加上標記 if (checkbox === selectClick || checkbox === cancelClick) &#123; inBetween = !inBetween; &#125; // 將有標記的checkbox勾選（以及selectClick） if (inBetween || checkbox === selectClick) &#123; checkbox.checked = false; &#125; &#125;) &#125;&#125;// 偵測checkbox的clickcheckboxes.forEach(checkbox =&gt; &#123; checkbox.addEventListener('click', handleCheck) &#125;);// 偵測當shift放開時讓click恢復未選取的狀態window.addEventListener('keyup', (e) =&gt; &#123; if (e.keyCode === 16 || e.shiftKey) &#123; click = undefined; &#125;;&#125;)]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」09 - Dev Tools Domination]]></title>
    <url>%2F2017%2F06%2FJavaScript30-09-Dev-Tools-Domination%2F</url>
    <content type="text"><![CDATA[主題介紹chrome的開發工具：DOM break on及13種console.的用法～ [DEMO]｜ [GitHub] ｜[JavaScript30全列表] DOM BREAK ON ..介紹了DOM的中斷點模式，分別有三種觸發模式可選（可複選） 1. subtree modifications: 當子元素點發生變化時2. arrtibute modifications: 當元素發生變化時3. node removal: 當元素被移除時使用方法為如圖，對選取的元素按下右鍵 &gt; Break on... 即可。 CONSOLE.THINGS介紹各種console用法 1. console.log()就是我們常用的那個log啦XD 2. console.log(‘%s’, value)可將字串中的%s顯示為指定的參數 3. console.log(‘%c’, font-style)可將字串顯示為參數中帶入的css樣式（font系列的style) 4. console.warning()顯示為警告圖示 5. console.error()顯示為錯誤圖示 6. console.info()顯示為資訊圖示 ！當我在測試時，並沒有出現資訊 7. console.assert()可以拿來測試判斷是否為真，若為false則回傳對應的錯誤訊息。 8. console.clear()清除console的所有訊息。 補充：Mac上清除的快捷鍵為⌘(Command)+K、Windows快捷鍵則為CTRL+L 9. console.dir()可以顯示選取物件的所有屬性，我寫的這個範例中，console.log(test)只能返回test本身的function內容，若使用console.dir(test)則可以印出test本身及其所擁有的屬性（注意屬性第一行run）。 10.console.groupCollapsed() &amp; console.groupEnd()可以把輸出資訊透過group包起來。 11. console.count()用來累加出現次數。 12.console.time() &amp; console.timeEnd()可以用來計算區域內執行的時間，我寫的範例是計算取回json資料的時間。 13.console.table()可以把資料整理成table格式方便瀏覽。 其他還有很多可以透過開發工具來協助的，例如監測整個網頁的讀取速度可以透過Network這個頁籤來查看，也可以設置模擬各種網路速度、或是離線狀態等.. 非常推薦觀看六角學院的免費課程，可以透過影片了解更多開發工具的操作範例。 推薦：六角學院-Chrome 網頁除錯功能大解密(免費)參閱：Google Dev Tool API]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DevTool</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript取出陣列重複/不重複值的方法]]></title>
    <url>%2F2017%2F06%2FJavaScript-Duplicates-Array%2F</url>
    <content type="text"><![CDATA[更新: Array-Object的處理JavaScript取出”陣列-物件“重複/不重複值的方法 今天早上群組有人問了這樣的問題：如何檢視[11, 22, 33, 44, 44, 55, 55, 66]的陣列重複值。經討論後出現了各種解法，覺得收穫很多紀錄下來。 以下敘述我將變數分別設定為： origin: 傳入要判斷的陣列，都是[1, 2, &#39;a&#39;, 3, 1, &#39;b&#39;, &#39;a&#39;] result: 不重複的回傳值 repeat: 重複的回傳值 ※以下順序為依據討論回答的順序決定，並非最佳解順序。 1. filter()我查了自己之前存在EverNote的資料，可以用ES6的filter()來解：123456789var origin = [1, 2, 'a', 3, 1, 'b', 'a'];var result = origin.filter(function(element, index, arr)&#123; return arr.indexOf(element) === index;&#125;);var repeat = origin.filter(function(element, index, arr)&#123; return arr.indexOf(element) !== index;&#125;);console.log(result); // [1, 2, "a", 3, "b"]console.log(repeat); // [1, "a"] 感謝FB社團-承諺提醒:filter()不是ES6新增的語法參閱：MDN-Array.prototype.filter() 2. Set()群組內的Dca大分享的方法，使用ES6的Set()來做唯一值確認，可以利用Set()提供的has與add來簡潔的達到篩選：12345678var origin = [1, 2, 'a', 3, 1, 'b', 'a'];var result = new Set();var repeat = new Set();origin.forEach(item =&gt; &#123; result.has(item) ? repeat.add(item) : result.add(item);&#125;)console.log(result); // &#123;1, 2, "a", 3, "b"&#125;console.log(repeat); // &#123;1, "a"&#125; 參閱：MDN-Set 3. Object + Object.keys()群內另一位龍大分享不使用ES6來完成的方法可以取得不重複值，也可以用物件去判斷出現次數來做重複值的選取：1234567var origin = [1, 2, 'a', 3, 1, 'b', 'a'];var result = &#123;&#125;;origin.forEach(function(item) &#123; result[item] = result[item] ? result[item] + 1 : 1;&#125;);console.log(Object.keys(result)); // ["1", "2", "3", "a", "b"]console.log(result); // Object &#123;1: 2, 2: 1, 3: 1, a: 2, b: 1&#125; 以下是我自己寫成其他形狀的紀錄..XD！只能取得結果字串，本身沒其他功能（例如原本的記數功能）！12345678var origin = [1, 2, 'a', 3, 1, 'b', 'a'];var result = &#123;&#125;;var repeat = &#123;&#125;;origin.forEach(function(item) &#123; result.hasOwnProperty(item)? repeat[item] ++: result[item] ++;&#125;);console.log(Object.keys(result)) // ["1", "2", "3", "a", "b"]console.log(Object.keys(repeat)) // ["1", "a"] 注意因為是使用Object.keys()來獲得重複/不重複的值，回傳為排序好的字串。關於為何需要repeat[item]++/repeat[item]++則是因為要建立該物件屬性，！需注意如果直接空值++會是NaN，可能會導致空值判斷錯誤 ！隨便賦予一個值來使屬性建立起來用而已，不一定要++，使用字串或其他都可如下：12345678910var obj = &#123;&#125;;obj['a']; // 沒賦值，此屬性不會被建立obj['b']; // 沒賦值，此屬性不會被建立console.log(obj); // Object &#123;&#125;console.log(Object.keys(obj)); // []obj['a']++; // 有賦值(直接++會得到NaN)，所以有建立屬性aobj['b'] = ''; // 有賦值(給了一個空字串'')，所以有建立屬性bconsole.log(obj); // Object &#123;a: NaN, b: ""&#125;console.log(Object.keys(obj)); // (2) ["a", "b"] 4. reduce()Dca大分享的方法2，可用來回傳不重複值123456var origin = [1, 2, 'a', 3, 1, 'b', 'a'];var result = origin.reduce((obj, item) =&gt; &#123; obj[item] = 1; return obj;&#125;, &#123;&#125;);console.log(Object.keys(result)); // ["1", "2", "3", "a", "b"] 或是將其出現次數記錄下來，之後在寫判斷次數取用(七索大提供思路)123456var origin = [1, 2, 'a', 3, 1, 'b', 'a'];var result = origin.reduce((obj, item) =&gt; &#123; obj[item] = obj[item] ? obj[item] + 1 : 1; return obj;&#125;, &#123;&#125;);console.log(result); // Object &#123;1: 2, 2: 1, 3: 1, a: 2, b: 1&#125; 參閱：MDN-Array.prototype.reduce() 5. Set() + Array.from()後來又查到的新方法，更加簡潔的獲取不重複值123var origin = [1, 2, 'a', 3, 1, 'b', 'a'];var result = Array.from(new Set(origin));console.log(result); // [1, 2, "a", 3, "b"] 參閱：MDN-Array.from 6. Set() + SpreadFB社團-建汶分享的，也是一個簡潔獲取不重複值的做法123var origin = [1, 2, 'a', 3, 1, 'b', 'a'];var result = [...(new Set(origin))];console.log(result); // [1, 2, "a", 3, "b"] 參閱：MDN-Spread syntax 其他關於Array的心得記錄「JS30紀錄＆心得」04 - Array Cardio Day 1「JS30紀錄＆心得」07 - Array Cardio Day 2]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」08 - Fun with HTML5 Canvas]]></title>
    <url>%2F2017%2F06%2FJavaScript30-08-Fun-with-HTML5-Canvas%2F</url>
    <content type="text"><![CDATA[主題使用HTML5的Canvas來製作一個畫布，透過滑鼠來繪製彩色粗細不一的線條～ [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1先在HTML的地方建立一個&lt;canvas&gt;的區塊，並設置一個變數ctx作為canvas的操作元素，設定顏色strokeStyle、樣式lineJoin、lineCap、lineWidth… Step2接著設定變數各種待會會應用到的變數12345678910111213const canvas = document.querySelector('#draw');const ctx = canvas.getContext('2d');canvas.width = window.innerWidth;canvas.height = window.innerHeight;ctx.strokeStyle = '#BADA55'; // 線條顏色ctx.lineJoin = 'round'; // 線條連接樣式（轉角）ctx.lineCap = 'round'; // 線條結束樣式ctx.lineWidth = 100; // 線條寬度let isDrawing = false; // 判斷是否執行畫圖中let lastX = 0; let lastY = 0;let hue = 0; // 色相值，在hsl中使用let direction = true; // 判斷粗細增減用 Step3寫function來執行畫圖！12345678910111213141516171819202122232425262728293031function draw(e) &#123; // 判斷是否`isDrawing`，`false`則`return`不觸發此function if (!isDrawing) &#123; return; &#125; // 設定線條顏色為hsl模式，吃變數hue ctx.strokeStyle = `hsl($&#123;hue&#125;, 100%, 50%)`; // 起始畫圖路徑 ctx.beginPath(); // 將路徑指針移動到X、Y點 ctx.moveTo(lastX, lastY); // 將起始點與目前滑鼠位置的X、Y用線條連接起來 ctx.lineTo(e.offsetX, e.offsetY); // 將線條繪製出來 ctx.stroke(); // 把結束點放進X、Y變數中 [lastX, lastY] = [e.offsetX, e.offsetY]; // 做顏色的變化效果，當色相值超過360後歸零 hue++; if (hue &gt;= 360) &#123; hue = 0; &#125; // 做線條寬度的變化效果，當寬度達到指令值得時候，切換direction的true/false if (ctx.lineWidth &gt;= 100 || ctx.lineWidth &lt;= 1) &#123; direction = !direction; &#125; if (direction) &#123; ctx.lineWidth++; &#125; else &#123; ctx.lineWidth--; &#125; &#125; Step4接著設定滑鼠對應的addEventListener效果12345678910// 當滑鼠按下時，將目前滑鼠的位置設定為變數中的X、Y並讓isDrawing為truecanvas.addEventListener('mousedown', (e) =&gt; &#123; isDrawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];&#125;);// 滑鼠移動中，執行function drawcanvas.addEventListener('mousemove', draw);// 滑鼠放開，滑鼠離開 都將isDrawing改為false不觸發function drawcanvas.addEventListener('mouseup', () =&gt; isDrawing = false);canvas.addEventListener('mouseout', () =&gt; isDrawing = false); Javascript語法&amp;備註direction = !direction學到的是透過這個方式來做true/false的切換。 HTML5語法&amp;備註這篇幾乎都是使用到canvas的功能，紀錄若要製作像這樣的畫布效果在canvas中的使用順序： 1. 定義線條樣式(1) strokeStyle線條顏色(2) lineWidth線條寬度(3) lineJoin線條的轉角樣式(4) lineCap線條的結束樣式 2. 移動順序(1) beginPath()開啟一個新的繪製路徑(2) moveTo()將繪製路徑的起點移動到指定的座標中(3) lineTo()連接路徑終點到指定的座標中(4) stroke()繪製路徑 參閱：MDN-CanvasRenderingContext2D 探索作者有提到最後可以去加入一個圖片相疊時的效果globalCompositeOperation還滿有趣的，可以再嘗試看看寫各種效果，或是弄幾個checkbox就可以設定很多畫筆跟效果了！ 參閱：CanvasRenderingContext2D.globalCompositeOperation]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>HTML5</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWS帳單退款記]]></title>
    <url>%2F2017%2F06%2Faws-bill-refund%2F</url>
    <content type="text"><![CDATA[之前自己在測AWS時忘記關閉服務，導致連續兩個月產生帳單..寫信與客服說明原因及確定這段期間並無使用後成功退費。 前天上班時收到信用卡即時刷卡通知1472元，回想了一下我沒有啥自動扣款是今天扣的，就打電話去銀行問，銀行告知是Amazon的網路消費，當下反應是我沒買東西，難道是盜刷，就請銀行端先幫我停卡，然後我去查原因。 … 結果是自己之前在測的服務忘記關啊啊啊，而且還不止五月份的帳單，連四月都有35.9美金的費用產生，但我完全沒注意到，可能就跟著帳單直接全繳了囧。 於是就寫信試著跟AWS反應看看，如果沒辦法也就認了畢竟自己忘記關，結果就是收到這張成功退款信啦，還很貼心的補了$10的credit來抵消本月帳單。 於是我就回傳首圖那隻貓及我的感謝給那位客服人員XD 之前開EC2也是開了兩台忘記關一台，真的要注意沒使用要關閉及信用卡扣款的問題啊…]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>AWS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13" MACBOOK PRO 2016]]></title>
    <url>%2F2017%2F06%2Ffirst-macbook-pro%2F</url>
    <content type="text"><![CDATA[自從二月使用了MacMini後，一直心很癢很想買Macbook…於是在生日時買了一台送自己，並在假期中把blog搬到hexo來。 終於啊，我買了人生第一台筆電！心癢癢很久了，雖然知道2017WWDC可能會出新規格的mbp，但在PCHOME看到跟我所定的規格一樣的機子，2016MBP NoTB RAM16GB的才50066硬是比官網便宜4000元，同時又是生日的期間，就當作給自己一份生日禮物買下去了XD 心得爽！！！ 對，沒了。 流水帳-忙碌的週末6/2 買了guahsu.io這個domain原本掛在大朵有一個guastudio.com，但想想還是用自己的帳號名稱比較好，於是在生日當天從gandi註冊了這個domain。 6/3 買了這台MBP及hub雖然是禮拜六，但因為補班的關係還是得上班，一早下單後就一直想回家摸電腦，也在當天跟一個01的網友買到很多人大推的hub！回家後就開箱瘋狂把玩，把mac mini晾在一邊了XD很可惜的是我的Dell螢幕很舊了，只有DVI跟D-SUB孔，我用HDMI轉DVI的線去轉一直顯示power save mode..插電視沒問題，用朋友的WINDOWS筆電轉也沒問題，上網查好像很多人都這樣，似乎是mac與dell的相容性問題？ 6/4 把之前的文章搬移到hexo決定把之前寫的blog文章跟github上的心得記錄轉到hexo中，花了一陣子研讀hexo的文件，後來建起來選用next這個主題，然後就開始把文章轉到hexo中(還好之前決定用markdown格式寫..) 6/5 建立github page把hexo整個傳到github上，用hexo d超快的啊XD同時把gandi買的domain轉來用。 其他Hexo建立透過官方文件倒沒什麼建置上的困難點，就不打算寫下紀錄了，要再找時間把JavaScript30挑戰做完！]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>BLOG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-ETH-Linstener]]></title>
    <url>%2F2017%2F05%2FJavaScript-ETH-Linstener%2F</url>
    <content type="text"><![CDATA[因為最近有再投資一點以太幣，而台灣唯一的交易所Maicoin買賣價錢跟收益要一直登進去看很麻煩，就自己寫了一個小網頁來看損益XD。 &gt;線上連結&lt; &gt;GitHub連結&lt;練習！主要就是每分鐘去取一次價格資訊，然後做計算，用了localstorage來記錄每次的設定，免得重整就沒了XD，也用了push.js來做通知功能，很簡單的設定PC的到價通知..(移動裝置無法囧)。]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」07 - Array Cardio Day 2]]></title>
    <url>%2F2017%2F05%2FJavaScript30-07-Array-Cardio-Day-2%2F</url>
    <content type="text"><![CDATA[主題延續[04 - Array Cardio Day 1]的Array各種操作，這次有5個範例。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟練習範例內有提供了2組資料： people：[ { name: ‘string’, year: number } ] comments：[ text: ‘string’, id: number } ] 要練習的題目為： people是否有19歲以上的人 People是否每個人都19歲以上 在comments中找到id是823423的資料 在comments中找到id是823423的資料索引值, 並透過索引值刪除這筆資料 JavaScript語法&amp;備註1. some()題目：people是否有19歲以上的人？解答：1const isAdult = people.some(person =&gt; ((new Date()).getFullYear()) - person.year &gt;= 19); 透過some()會將Array中的資料逐筆進行判斷，只要有一筆通過判斷則回傳true並結束。 參閱：MDN-Array.prototype.some() 2. every() 題目：people是否每個人都19歲以上？解答：1const allAdults = people.every(person =&gt; ((new Date()).getFullYear()) - person.year &gt;= 19); every()會對Array中的每筆資料進行判斷，只要有一筆不符合則回傳false並結束。與some()是相反操作的感覺。 參閱：MDN-Array.prototype.every() ３. find() 題目：在comments中找到id是823423的資料解答：1const comment = comments.find(comment =&gt; comment.id === 823423); find()會對Array中的資料逐筆進行判斷，返回第一筆符合條件的值，若都沒有符合的值，將返回undefined。 參閱：MDN-Array.prototype.find() 4. findIndex() &amp; slice() &amp; spared題目：在comments中找到id是823423的資料索引值, 並透過索引值刪除這筆資料解答：12345const index = comments.findIndex(comment =&gt; comment.id === 823423);const newComments = [ ...comments.slice(0, index), ...comments.slice(index + 1)]; 首先透過findIndex()對Array中的資料逐筆進行判斷，返回符合條件的索引值，接著利用spared也就是省略符號...來進行展開陣列並透過slice()組合陣列，...comments.slice(0, index),這段先將陣列開頭到索引值前的資料加進來，...comments.slice(index + 1)這段則是將索引值+1後延續到陣列結束的資料加進來。slice()的第一個參數是陣列索引的起點，第二個是終點（且不會被使用）無填寫則是到結束。 參閱：MDN-Array.prototype.findIndex()MDN-Spread syntaxMDN-Array.prototype.slice()]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」06 - Type Ahead]]></title>
    <url>%2F2017%2F05%2FJavaScript30-06-Type-Ahead%2F</url>
    <content type="text"><![CDATA[主題利用fetch()來取回json檔案，並透過filter()及RegExp()等語法來製作搜尋即時顯示關聯效果！ [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1預設已經有建立了一個城市的.json清單，先建立一個空的陣列cities並透過fetch來取得json資料存進去。 Step2建立function findMatches(wordToMatch, cities)裡面建立了一個RegExp用於match來進行字串比對 Step3建立displayMatches()並用addEventListener來監測輸入框的change&amp;keyup，每次鍵盤輸入時都會觸發displeyMatches()來處理比對，將比對結果用map來return 組合的HTML的&lt;li&gt;資料， Javascript語法&amp;備註fetch()操作心得待補… 我原先只用過XMLHttpRequest來取資料，關於promise及fetch的操作目前並不熟悉。參閱：MDN-fetch RegExp()正規表達式，這個真的非常複雜…我有做紀錄的就是參數後面g代表全部, i代表不分大小寫.. 參閱:MDN-RegExp .join()將陣列資料用參數內的字串連接轉為一個字串，範例中上了join(&#39;&#39;)來避免map回傳的陣列有,產生。 CSS語法&amp;備註nth-child()範例中利用nth-child(odd)與nth-child(even)來抓li的奇偶數 參閱：MDN-:nth-child 探索加個排序最簡單的小調整，加個.sort()讓搜尋結果進行排序顯示123456789101112131415function displayMatches() &#123; const matchArray = findMatches(this.value, cities); const html = matchArray.map(place =&gt; &#123; const regex = new RegExp(this.value, 'gi'); const cityName = place.city.replace(regex, `&lt;span class="hl"&gt;$&#123;this.value&#125;&lt;/span&gt;`); const stateName = place.state.replace(regex, `&lt;span class="hl"&gt;$&#123;this.value&#125;&lt;/span&gt;`); return ` &lt;li&gt; &lt;span class="name"&gt;$&#123;cityName&#125;, $&#123;stateName&#125;&lt;/span&gt; &lt;span class="population"&gt;$&#123;numberWithCommas(place.population)&#125;&lt;/span&gt; &lt;/li&gt; `; &#125;).sort().join(''); suggestions.innerHTML = html;&#125;]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」05 - Flex Panel Gallery]]></title>
    <url>%2F2017%2F05%2FJavaScript30-05-Flex-Panel-Gallery%2F</url>
    <content type="text"><![CDATA[主題用CSS與JS來製作一個點擊後會動畫展開的圖片展示效果，運用到了CSS的flex、transform、transition.. 這篇比較偏向css知識！ [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1由於整體HTML的tag是由1個panels包覆5個panel，為了使其設定為flex，先在外層容器panels加上display: flex接著為每個panel加上flex: 1來使各子元件最大占比為1也就會變成同容器中的5個元件都設1，那就是每個元件最大占比為20%。(因對flex並不熟悉，我是用占比來理解，若有錯請在指正..感謝@@) Step2在為panel加上justify-content: center使其水平置中，並在加上了display: flex及flex-direction: column，再加上一層display: flex可以使panel底下的元件也變成flex控管 Step3對panel底下的first-child及last-child做位移效果，使其能在預設狀態於可視範圍外，並設計open-active當觸發時，配合transition產生移回原位的動畫，也在.panel.open中新增了flex: 5使其觸發時會有展開的動畫。 Step4編寫JS先取得所有panel的節點，接著設計toggle function使執行的物件藉由.classList.toggle來新增/移除動畫class並透過addEventListener來監測當click&amp;transitionend時觸發toggle function。 .classList&amp;transitionend&amp;toggle在&gt;第一篇&lt;剛好有提到。 Javascript語法&amp;備註e.propertyName &amp; includes()在範例中，觸發動畫效果的順序為： click其中一張圖(panel)觸發addEventLinstner中的toggleOpen 為其增加.open，增加Flex: 5的效果，同時也是使用了.panel中的transition: flex這段 當.open的transition結束時，觸發了transitionend來作動toggleActive 為其增加.open-active效果，讓原本可是範圍外的p文字滑入 在順序:4時有個判斷，12345function toggleActive(e) &#123; if (e.propertyName.includes('flex')) &#123; this.classList.toggle('open-active'); &#125;&#125; e.propertyName可以抓到觸發transitionend的屬性名稱，而.open中觸發的transition屬性有兩個，分別為font與flex要使其在flex之後在觸發的話，就要判斷進來的是不是flex但因為transition: flex 0.7s..這段在sarafi是flex，而其他瀏覽器為flex-grow所以不能用e.property === &#39;flex&#39;來寫，會使其中一方瀏覽器抓不到值，作者提到因為兩者都有flex的字眼，所以利用.includes(&#39;flex&#39;)來判斷， 只要e.property`有包含到flex的字串就使其通過判斷，加入動畫效果。 參閱:MDN-String.prototype.includes() CSS語法&amp;備註flexflex我目前還不熟，他還在我的待讀清單中XD僅依據目前這篇使用到的做筆記： display: flex把該容器設定為flex模式，可以在其他flex中設定(角色為子元素時) flex: flex-grow flex-shrink flex-basisflex的簡寫，第一個為占比、第二個為壓縮值、第三個為默認尺寸 flex-directionflex排列的方向，colume(垂直向)或row(水平向)，預設為row 行與列的中文用法，我自己有點混淆像是我會說第314行要加個分號喔，也會說工具列上第3個icon兩者都是在描述水平向，但我卻用了不同的字去形容囧 justify-content &amp; align-items依據flex-direction設定的主/側軸來決定排列方式，例如設定flex-direction: row那麼justify-content: center就指水平置中，而align-items: center代表垂直置中。參閱：MDN-CSS Flexible Box Layout :first-child() &amp; :last-child()CSS的:偽類別，分別可以選取first(第一個)/last(最後一個)子元素，在範例的panel中，除了主圖的大字外，上下各有一個p包含了點擊後進場的動畫文字：12345&lt;div class="panel panel1"&gt;&lt;p&gt;Hey&lt;/p&gt;&lt;p&gt;Let's&lt;/p&gt;&lt;p&gt;Dance&lt;/p&gt;&lt;/div&gt; 透過panel &gt; *:first-child選取Hey透過panel &gt; *:last-child選取Dance 探索當展開其中一個時，在點其他的panel並不會關閉第一個已展開的效果，若要達到每次點擊都是一個聚焦效果(關閉其他已展開的)的感覺得話，我是這麼做的：12345678910111213//宣告一個上次點擊的Panel，預設先給他panelslet lastClickPanel = document.querySelector('.panels');function toggleOpen() &#123; //每次檢查進入的element與上次進入的element是不是相同 //若不相同，則把上次點擊的element移除opev效果 //再把lastClickPanel指向為這次的elment if (this !== lastClickPanel) &#123; lastClickPanel.classList.remove('open'); lastClickPanel = this; &#125;this.classList.toggle('open');&#125;]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」04 - Array Cardio Day 1]]></title>
    <url>%2F2017%2F05%2FJavaScript30-04-Array-Cardio-Day-1%2F</url>
    <content type="text"><![CDATA[主題用了8個範例來介紹關於Array的各種操作。。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟練習範例內有提供了3組資料： inventors：first(名)、last(姓) 、year(出生日期)、passed(逝世日期) people：逗點分隔的姓名(firstName, lastName) data：在練習8中提供的一組包含重覆資料的陣列 要練習的題目為： 篩選出於1500~1599年間出生的inventor(year in 1500-1599) 將inventors內的first與last組合成一個陣列 依據生日由大至小排序所有的inventor 加總所有inventor的在世時間 依據年齡由大至小排序所有的inventor 列出wiki中巴黎所有包含’de’的路名(在wiki中透過querySelectorAll來選取資料作篩選) 依據lastName排序所有people的資料 分別計算data內每個種類的數量 JavaScript語法&amp;備註1. filter()題目：篩選出於1500~1599年間出生的inventor(year in 1500-1599)解答：透過fifter()對來源做篩選，會將結果為true的資料組成陣列回傳1234567const fifteen = inventors.filter(function(inventor) &#123; if(inventor.year &gt;= 1500 &amp; inventor.year &lt;= 1600) &#123; return true; &#125;&#125;);//可簡化為arrow functionconst fifteen = inventors.filter(inventor =&gt; (inventor.year &gt;= 1500 &amp; inventor.year &lt;= 1600)); 參閱：MDN-Array.prototype.filter() 2. map()題目：將inventors內的first與last組合成一個陣列解答：透過map來將firstName/lastNam組合返回陣列12const fullNames = inventors.map(inventor =&gt; `$&#123;inventor.first&#125; $&#123;inventor.last&#125;`); console.log(fullNames); 參閱：MDN-Array.prototype.map() 3. sort()題目：依據生日由大至小排序所有的inventor解答：透過sort()來做排序12345678910const ordered = inventors.sort(function(a, b) &#123; if(a.year &gt; b.year) &#123; return 1; &#125; else &#123; return -1; &#125;&#125;);//利用箭頭函式及三元運算式可簡寫如下const ordered = inventors.sort((a, b) =&gt; a.year &gt; b.year ? 1 : -1);` 若比對的值相同要依據原排序的話，要再加上一個return 0的判斷使其保持原排序參閱：MDN-Array.prototype.sort() 4. reduce()題目：加總所有inventor的在世時間解答：要加總的話，用以前的寫法會寫這樣12345let totalYears = 0;for (let i = 0; i &lt; inventors.length; i++) &#123; let liveYear = inventors[i].passed - inventors[i].year; totalYears += liveYear;&#125; 如果利用reduce()搭配箭頭函式如下：123const totalYears = inventors.reduce((total, inventor) =&gt; &#123; return total + (inventor.passed - inventor.year);&#125;, 0); redice()的callback有四個參數： 初始值 陣列中正在處理的元素 陣列中正在處理的元素的索引值（好饒舌ＸＤ） 使用reduce的陣列及一個預設值(會再第一次執行時賦予第一個參數設定的值。 所以用這個答案來看，在第一次執行時預設值賦予了total=0接著每次讀取陣列元素時對其計算在世時間並加回total中。 參閱：MDN-Array.prototype.reduce() 5. sort()題目：依據年齡由大至小排序所有的inventor。解答：排序原理同第三題，多了一段計算年齡的部分而已12345const oldest = inventors.sort(function (a, b) &#123; const lastInventor = a.passed - a.year; const nextInventor = b.passed - b.year; return lastInventor &gt; nextInventor ? -1 : 1;&#125;); 6. map() + filter() &amp; includes()題目：列出wiki中巴黎所有包含’de’的路名解答：12345const category = document.querySelector('.mw-category');const links = Array.from(category.querySelectorAll('a'));const de = links .map(link =&gt; link.textContent) .filter(streetName =&gt; streetName.includes('de')); 這題先用querySelectorAll()來選取對象元件，再利用之前第一個練習有提到的Array.from將nodeList轉為Array，才能對其進行map操作(map是Array的方法，nodeList沒有)，同時加上filter+includes來做文字的篩選，若存在’de’就回傳true加入陣列。 參閱：MDN-Array.prototype.includes() 7. sort() &amp; split()題目：依據lastName排序所有people的資料解答：12345const alpha = people.sort((lastOne, nextOne) =&gt; &#123; const [aLast, aFirst] = lastOne.split(', '); const [bLast, bFirst] = nextOne.split(', '); return aLast &gt; bLast ? 1 : -1;&#125;); 由於people的資料都是[&#39;Beck, Glenn’]這樣的逗點字串，要取得lastName就必須要使用split()來切開，滿酷的是因為split()會返回陣列，所以宣告了陣列[aLast, aFirst]來接值接著再利用接到的值來做排序比對。 參閱：MDN-String.prototype.split() 8. reduce()題目：分別計算data內每個種類的數量解答：123456789const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck', 'pogostick'];const transportation = data.reduce(function (obj, item) &#123; if (!obj[item]) &#123; obj[item] = 0; &#125; obj[item]++; return obj;&#125;, &#123;&#125;); 這題的做法真的很厲害啊！首先利用預設值將reduce()的第一個參數設定為空物件obj={}接著做一個判斷來決定建立物件內容或著使已建立內容累加總數! 探索將上面用到的技巧應用到一個常會遇到的統計問題題目：試著將統計people的所有單字拆開，並統計各單字共出現次數(僅包含英文字)解答：1234567891011const strCnt = people.reduce(function (obj, item) &#123; const itemStr = item.match(/[a-zA-Z]/g, ''); itemStr.forEach(str =&gt; &#123; if (!obj[str]) &#123; obj[str] = 0; &#125; obj[str]++ &#125;) return obj;&#125;, &#123;&#125;);console.log(strCnt); 同第8題，先宣告一個空陣列來傳入item，接著將每個item透過match()拆開只取英文字，再利用forEach來建立內容或是累加總數。]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」03 - CSS Variables]]></title>
    <url>%2F2017%2F05%2FJavaScript30-03-CSS-Variables%2F</url>
    <content type="text"><![CDATA[主題用JS與CSS搭配製作一個即時的濾淨效果，特效為調整內距、模糊、邊框色。 [DEMO]｜ [GitHub] ｜[JavaScript30全列表] 步驟Step1利用CSS variable來定義CSS的變數(有點像sass的感覺) Step2利用addEventLinstener來綁HTML的控制桿，並更新值到CSS變數中來達到即時調整的效果。 Javascript語法&amp;備註dataset用dataset可以取出對象的data-*屬性，也等同於getAttribute123&lt;div id="test" data-no="123"&gt;&lt;/div&gt;document.querySelector('#test').dataset.no // 輸出123document.querySelector('#test ').getAttribute('data-no'); // 輸出123 style.setProperty()等同於style.cssPropertyName123style.setProperty('padding', '15px');/* 等同於 */style.padding = '15px'; 但在實際應用中，前者的做法會很方便帶參數進去。 參照:MDN-setProperty CSS語法&amp;備註filter:blur()CSS3的濾鏡功能，blur是高斯模糊，參數越高越模糊。 參照:MDN-filter 探索依樣畫葫蘆的新增了grayscale()的效果，在CSS中要使用兩個以上的濾鏡效果寫再一起就好，如果分開來的話會變成覆蓋：123456789/* 這樣會變成覆蓋，剩下garyscale的效果 */img &#123; filter: blur(10px); filter: grayscale(10%);&#125;/* 寫在同一處，才能吃到兩個效果 */img &#123; filter: blur(10px) grayscale(10%);&#125;]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」02 - JS and CSS Clock]]></title>
    <url>%2F2017%2F05%2FJavaScript30-02-JS-and-CSS-Clock%2F</url>
    <content type="text"><![CDATA[主題用JS與CSS搭配製作一個實時的時鐘效果。 [DEMO] ｜ [GitHub] ｜ [JavaScript30全列表] 步驟Step1. 製作時針、分針、秒針利用classhand樣式來表現出時分秒針的樣式 Step2. 設定定時器利用setInterval(setDate, 1000);每秒取得當前時間 Step3. 利用當前時間來取得對應角度將每秒取得的時間在setData裡面取出，並計算出對應角度再透過element.style.tranform來變更CSS效果，產生位移的感覺。 Javascript語法&amp;備註let &amp; const對於ES6新增的區域變數宣告與常數宣告我知道的是const需要的是一開始就指定值，且不可再被指定但在之前的經驗裡，function內我還是會放let來做變數的宣告，實際上若該值不會再被變動，應該是用const做宣告比較好的。 Date()取得時間的函數，一定要搭配new來使用new Date()date.getSeconds()：取得當前秒date.getMinutes()：取得當前分鐘date.getHours()：取得當前小時 setInterval()定時器，有兩個參數setInterval(callback, time)第一個是要執行的function，第二個是時間(毫秒) CSS語法&amp;備註transform-oragin變形的軸心，預設為物件的中心點，在這個範例中，設定為100%(right)可以使其從時鐘面的中心點開始旋轉。 transform:rotate()旋轉物件，數值後方要加上角度deg，可超過360度，正值為順時針轉，負值為逆時針旋轉。 transition-timing-function: cubic-bezier()設定動畫轉場所依據的貝茲曲線，可以透過chrome的開發者工具來進行可視化調整。 參閱：MDN-transform 探索轉了個角度，調了點指針為了要讓指針從12點方向(0點)開始計算，作者將指針.hand都加上了rotate(90deg)來轉，並在計算時間的function內最終結果也都+90，我是改成到clock-face直接將整個區塊轉90度，這樣在計算時就不用+90，可以用最大360來做計算了。 另外也把時分秒針調整粗細度．．就這樣ＸＤ transform:rotate的彈跳問題作者最後有提到一個小問題，若指針在354度切到0度時，會使指針往前彈回去，這是因為有使用transtion，在角度做切換時會加上的動畫效果，354→0度會認為是往前，而非轉一圈回到起點，所以動畫先往前轉到0。為了避免這個反彈的怪現象，我加上了一個function來處理角度12345678function setRotate(deg) &#123;if (deg === 0) &#123; document.querySelector('.hand').style.transition = 'all 0s';&#125; else &#123; document.querySelector('.hand').style.transition = 'all 0.05s';&#125;return `rotate($&#123;deg&#125;deg)`;&#125; 當計算角度為0時，把動畫效果關閉，這樣就可以避免了！]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS30紀錄＆心得」01 - JavaScript Drum Kit]]></title>
    <url>%2F2017%2F05%2FJavaScript30-01-Java-Script-Drum-Kit%2F</url>
    <content type="text"><![CDATA[主題透過JS使鍵盤按下後播放出對應按鍵的聲音，並同時產生一個特效，在按下其他鍵後會關閉該特效並於新按鍵中啟用。 [DEMO] ｜ [GitHub] ｜ [JavaScript30全列表] 步驟Step1. 新增keydown listener利用window.addEventListener(&#39;keydown&#39;, playSound);來監聽鍵盤動作。 Step2. 建立functionplaySound 利用傳入的e.keyCode來取得對應的audio標籤及該按鍵的div標籤 判斷傳入的e.keyCode是否有對應的audio標籤，若無則退出 使對應的div加上playing樣式，產生對應的典及特效 使對應的audio播放時間為0 播放對應的音檔 Step3. 新增transitionend listener 偵測所有包含className=&#39;key&#39;的元件 當該元件觸發特效並結束時(transitionend)，呼叫removeTransition Step4. 建立functionremoveTransition 判斷傳入的propretyName是否為transform，若否則退出 若為transform，則移除playing樣式 JavaScript語法&amp;備註element.classList這個會回傳element的class值(陣列)，範例用到了classList的方法add()及remove()12classList.add(&apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos;); //新增多個classNameclassList.remove(&apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos;); //移除多個className 如果已經存在/不存在的className則會被忽略。 還有其他方法如:toggle()偵測是否存在這個className，存在則刪除/不存在則新增contains()偵測是否存在這個className, 返回true/false參閱：MDN-Element.classList HTMLmediaElement(audio)HTML的audio標籤，在HTML放置如下標籤指定音源1&lt;audio src=&quot;sound/a.mp3&quot;&gt;&lt;/audio&gt; 透過javascript來操作：element.play():進行播放element.currentTime:指定播放秒數範例中使用currentTime是為了達到連發的效果XD 參閱：MDN-HTMLMediaElement forEach之前沒在javascript中使用的語法，用法如下：1arr.forEach(callback function) 我是用for迴圈來比對做語法理解的：1234567891011121314151617181920let datas = ['data1', 'data2', 'data3'];//for迴圈寫法for (let i = 0; i &lt; datas.length; i++) &#123; console.log(datas[i]);&#125;//forEach寫法datas.forEach(function(data)&#123; console.log(data);&#125;);//都會輸出//data1//data2//data3datas.forEach(console.log);//如果透過上面直接console.log來看到結果是：//data1 0 ["data1", "data2", "data3"]//data2 1 ["data1", "data2", "data3"]//data3 2 ["data1", "data2", "data3"]//回傳的分別是value, index, array本身內容。 參閱：MDN-Array.prototype.forEach() 箭頭函式(Arrow Function)ES6的新語法123456//傳統寫法let func1 = function(arg) &#123; console.log('Hi, ' + arg); &#125;;//箭頭函式寫法let func2 = arg =&gt; console.log('Hi, ' + arg);//補充:如果該function沒有參數要傳，要帶空括號如下let func3 = () =&gt; console.log('Hi'); 參閱：MDN-Arrow functions addEventListener因為我是是第一次看到transtionend這個event，所以去MDN查了HTML DOM event記錄連結在此 參閱：MDN-Event reference template literals模板文字，同樣屬於第一次看到的東西，利用` - 反引號(back-tick)或稱重音符(grave accent)來組合字串，在範圍內可利用${}加上變數操作 例如原本的字串+變數組合寫法：123let str = '&lt;div data-key="' + key + '"&gt;' + '&lt;button&gt;click me&lt;/button&gt;' + '&lt;/div&gt;'; 改用template string來做只要123let str = `&lt;div data-key="$&#123;key&#125;"&gt; &lt;button&gt;click me&lt;/button&gt; &lt;/div&gt;`; 用` 包住字串，利用${}來包變數這樣可以很輕鬆的組出易於閱讀的組合字串！不用像以前還要注意單雙引號與+的配合了~ 參閱：MDN-Template literals Array.from範例中有這段1const keys = Array.from(document.querySelectorAll('.key')); 查詢了Array.from才知道這是一個將一個物件或是字串轉為陣列格式的語法，但當時覺得為何要把陣列在轉成陣列?querySelectorAll不就是返回陣列嗎?在查下去才發現querySelectorAll返回的是nodeList且nodeList跟Array是不同的!雖然都很像陣列，但nodeList並沒有array.prototype上的方法！最簡單的例子是用array.push()去測試，會發現由querySelectAll得到的物件無法用.push()。12345let testNodeList = document.querySelectAll('.key');testNodeList.push('add'); // &lt;--非陣列會報錯TypeError: testNodeList.push is not a functionlet testArray = Array.from(testNodeList);testArray.push('add'); // &lt;-- 轉為陣列就可以了 至於在範例中轉型的原因，我想應該是因為若無轉型為Array使用nodeList來forEach可能會導致某些瀏覽器版本錯誤。 nodeList由querySelectorAll及childNodes返回的參閱：MDN-NodeList CSS語法&amp;備註display:flexCSS3的排版語法，以範例中的來做備註紀錄1234567.keys &#123; display: flex; /*要使用flex要在元素內先宣告flex*/ flex: 1; /*這是一個簡寫，全部為flex: flex-grow｜flex-shrink｜flex-basis*/ min-height: 100vh; /*vh代表view height, 百分比呈現*/ align-items: center; /*宣告為flex後才有效的屬性，垂直置中*/ justify-content: center;/*宣告為flex後才有效的屬性，水平置中*/&#125; 參閱：MDN-flex 探索原範例只能由鍵盤觸發，我的探索是為這個範例加上可由滑鼠點擊觸發的功能123456789101112131415161718const keys = Array.from(document.querySelectorAll('.key'));//新增click功能綁定至每個class="key"keys.forEach(key =&gt; key.addEventListener('click', playSound));function playSound(e) &#123; //依據不同的事件來取得對應的key_code(e.type可以看，以下是簡寫版) let keyCode = e.keyCode || this.getAttribute('data-key'); const audio = document.querySelector(`audio[data-key="$&#123;keyCode&#125;"]`); const key = document.querySelector(`div[data-key="$&#123;keyCode&#125;"]`); if (!audio) return; key.classList.add('playing'); audio.currentTime = 0; audio.play();&#125;]]></content>
      <categories>
        <category>JavaScript30</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript練習-臺北市旅遊景點]]></title>
    <url>%2F2017%2F05%2FJavaScript-TravelMap%2F</url>
    <content type="text"><![CDATA[這兩個禮拜再重新看過javascript，並做了一個台北市旅遊景點導覽的網頁，使用了政府資料開放平臺的DATA，紀錄這次使用到的功能及心得。 DEMOGITHUB 實作內容這次用了HTML、CSS、JavaScript這些前端基本語言，來實作一個台北市的旅遊景點資料站，資料來源是政府資料開放平臺，樣式的部分還是簡單的HTML跟CSS刻，主軸放在Javascript上，紀錄這次在JavaScript上遇到跟重新學習理解到的東西。 querySelector &amp; querySelectorAll元素選擇器！還記得以前最常使用的就是要找ID時用document.getElementById()，當要找Class的時候要用getElementsByClassName()。 而這次學習了使用querySelector()以及querySelectorAll()這兩個函式：共通點是都可以用css的規則來作為選擇，例如ID用#，ClassName用.來操作，例如：1234&lt;div id="divID"&gt;AAA&lt;/div&gt;&lt;div class="divClass"&gt;BBB&lt;/div&gt;&lt;div class="divClass"&gt;CCC&lt;/div&gt;&lt;div data-no="1"&gt;DDD&lt;/div&gt; 要取得AAA的資料可以透過querySelector(&#39;#divID&#39;)要取得BBB的資料可以透過querySelector(&#39;.divClass&#39;)要取得DDD的資料可以透過querySelector(&#39;div[data-no=&quot;1&quot;]&#39;) 但是若有重複的className透過querySelector(&#39;.divClass&#39;)只會取到第一筆BBB的值，所以就要用querySelectorAll(&#39;.divClass&#39;)來取得所有className是.divClass元素，但特別要注意的的是，透過querySelectorAll()取得的值會被放入陣列中，所以例如寫了：var data = document.querySelectorAll(&#39;.divClass&#39;).textContent;會得到[&#39;BBB&#39;,&#39;CCC&#39;]這樣的內容，要取出BBB就是data[0]！ 學到這裡時，真心覺得jQuery的$(&#39;&#39;)真的很方便啊XD！ addEventListener綁定事件，使用方法是element.addEventListner(事件, 執行內容, useCapture) 事件指的是要偵測的事件，例如點擊click，內容變換change、鍵盤動作keyCode 執行內容指的是要執行的項目，可以直接指定function或直接寫在裡面例如：document.body.addEventListner(&#39;click&#39;, SomeFunction, true);document.body.addEventListner(&#39;click&#39;, function(e) { console.log(e) }, false);要注意的是當使用第一種方法直接呼叫別的function時，不能傳參數，若要傳參數只能在包一層function，例如：document.body.addEventListner(&#39;click&#39;, function(e) { SomeFunction(param) }, false); useCapture目前沒有使用情境，老實說並不是很了解的參數，但他是一個true/false的設定值，預設是false。當設定為true時，會從指定元素的最外層元素開始往內層執行，反之設定為false則從指定元素開始往外層執行，舉例： 1234&lt;div class="father"&gt; &lt;div class="child"&gt; &lt;/div&gt;&lt;/div&gt; 當設定document.querySelector(&#39;.child&#39;).addEventListener(&#39;click&#39;,function() { console.log(&#39;C&#39;) }), ture)document.querySelector(&#39;.father&#39;).addEventListener(&#39;click&#39;,function() { console.log(&#39;F&#39;) }), ture)會先印出F（外層），若設定為false時會先印出C（內層）若father設定false，child設定成ture，則會先印C，反之則先印F function(e){}這次使用了很多fuction的狀態偵測，例如前兩個querySelectorAll跟addEventListner組合時就會用到：1234567891011/** * 景點資料按鈕功能綁定 */function setReadMoreButton() &#123; var readMoreButton = document.querySelectorAll('.button--readMore'); for (var i = 0; i &lt; readMoreButton.length; i++) &#123; readMoreButton[i].addEventListener('click', function(e) &#123; showViewData(e.srcElement.getAttribute('data-viewNo')); &#125;, false); &#125;&#125; 透過e.srcElement來取得觸發事件的元素，進一步取得要操作的值。 XMLHttpRequest為了要獲取JSON內容來使前端動態組成景點內容，使用XHR(XMLHttpRequest)來做：123456789101112131415161718192021222324/** * 取得台北市行政區資料 * 透過AJAX取得JSON資料 */var areaData = ''; //全部的行政區資料(全域變數)function getAreaData() &#123; //建立一個新的XMLHttpRequest var xhr = new XMLHttpRequest(); //設定這個xhr來get放在data資料夾底下的json檔案 xhr.open('get', 'data/viewZip.json', true); //傳送這個xhr的請求 xhr.send(null); //當取得xhr回應後,執行這個function xhr.onload = function() &#123; //檢查狀態碼，若非200連線OK則顯示錯誤訊息 if (xhr.status == 200) &#123; areaData = JSON.parse(xhr.responseText); createAreaSelect(); //建立行政區下拉選單 getViewData(); //取得景點資料 &#125;else &#123; document.querySelector('.box-area').innerHTML = '&lt;h2&gt;取得資料時發生錯誤，請檢查網路狀態並重新整理：）&lt;/h2&gt;'; &#125; &#125;&#125; window.historyAJAX動態組成的資料在使用者眼裡看起來像是換了一頁，但實際上網頁本身並沒有切換頁面，只是”替換“了內容，所以自然瀏覽器也不會去紀錄上一頁、下一頁的資料，導致切了很多內容後，想回到上一頁卻離開了這個網站。 為了解決這個問題，就要自己產生紀錄！從window.history中可以得知每次對頁面的切換都會有紀錄，可以透過history.pushState(object, title, url)來增加紀錄。參數分別是（要寫進紀錄的值、標題、網址），其中第二個參數目前是沒作用的。 並可用window.onpopstate來偵測瀏覽器的上、下頁行為以這個實作的範例來說，我的想法跟流程是這樣： 進入網頁時，先寫入當時的行政區與頁碼到history.state中，並同時在localStorage寫入相同值，當使用者點擊上、下頁時，將寫入的值取出並透過這組值來重組頁面資料，達到切頁的效果。 localStorage寫入值的用途為當重新整理時，要撈到重整前的值來重組畫面，故當程式呼叫到寫入瀏覽紀錄時也要寫、動作切上下頁時也要寫入。 1234567891011121314/** * 寫入瀏覽紀錄 * @param &#123;*&#125; areaName 行政區 * @param &#123;*&#125; pageNo 頁碼 */function setHistory(areaName, pageNo) &#123; //紀錄當前行政區及頁數,並儲存在localstorage中 //建立紀錄資料變數historyData，並將行政區與頁碼用字串方式存入變數中 var historyData = '&#123;"areaName":"' + areaName + '","pageNo":' + pageNo + '&#125;'; //將當前紀錄資料存入瀏覽歷史中 history.pushState(historyData, '', ''); //將當前紀錄資料存入localStorage中，儲存最後一次瀏覽的頁面資訊 localStorage.setItem('lastPage', historyData);&#125; 12345678910111213141516/** * 處理瀏覽器上下頁行為 */window.onpopstate = function(e) &#123; if (e.state) &#123; //將當前的頁面存入localStorage中，儲存最後一次瀏覽的頁面資訊 localStorage.setItem('lastPage', e.state); //解析動作取得的瀏覽紀錄 var historyData = JSON.parse(e.state); //組出對應的景點資料 setViewData(historyData.areaName, historyData.pageNo); &#125; else &#123; //若已經沒有自己寫入的值，就直接進行預設的上一頁動作 history.back(); &#125;&#125; CSS小小紀錄一下這次CSS遇到的狀況： 使用BEM命名規則 各種變數跟樣式命名真的是我很弱的一部份，除了英文很破沒幾個單字可以拿來命名之外，就是沒有一個規範可以去遵循，後來從前端電子報中看到這個BEM這個關鍵字，這種命名方式是遵循Black__Element–Modifier這樣的方式去命名的，雖然看起來很長很亂，但其實對健忘的我來說很好找到對應元素，不過block in block的處理及modifier的定義我沒有很充分理解，第一次使用，會再找機會參考別人的做法。 select變更樣式 HTML的原生select修改樣式成背景透明後，在手機上的小箭頭居然會不見!background-color: rgba(255, 255, 255, 0) 原本想說使用圖片來替代，後來因為解析度的關係(箭頭會看起來糊糊的)，在select旁邊寫了一個svg的小箭頭來換頂替。123&lt;svg class="content__select--arrow"&gt; &lt;polygon fill="#42ab9e" points="5,10 0,0 10,0"&gt;&lt;/polygon&gt;&lt;/svg&gt; 且為了安全起見，也還是把select的圖標隱藏了-webkit-appearance: none;然後這個我根本沒有在管瀏覽器兼容性啦XD! 總結寫程式這條路一直到現在都還是自學的狀態，前端的HTML/CSS/JavaScript，後端JAVA/PHP，就是自己一直查一直找，很多東西能做出來，但總覺得底氣不足… 這就造成了很多時候基本功不足，也不能了解問題發生的原因，常常遇到了問題就去google找答案，而解法百百款，總有些看不懂的好解答。 這次找了幾門線上課，打算按部就班的來重打基礎，從JavaScript開始（六角學院）、（克服JS的奇怪部分），開始看了之後有很多”啊哈，原來如此“的感覺，六角學院的老師的講解很清楚，觀念都有清楚帶到，克服JS的奇怪部分還沒看完，不過他說話的速度滿不錯的也可當練習英文聽力..XD 目前想把javascript搞清楚，然後嘗試學習後端node.js的部分..再來看前端的各種框架囧 雖然所學所會的於目前工作上沒用到幾個，但還是要持續加強自己的能力，我想總有一天會用上的…]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三月紀錄]]></title>
    <url>%2F2017%2F04%2Flog-201703%2F</url>
    <content type="text"><![CDATA[女兒出生啦～又有更多需要學習的了！記錄一下目前用到的新東西跟部分購買項目！ 可愛的女兒在2/28出生了！過年期間買了支iPhone 6s，原本只想買32GB的覺得已夠用，現在想想還好當初缺貨改買128GB的，一直拍女兒照片一下就用40G了。記錄一下這整個月用到的新東西，跟部分購買物。 [APP]Google Photos非常好用的APP，從之前拿A9時開始使用的，拍照後可以自動同步到google account中，容量則是選用原尺寸(高畫質的話無限，原尺寸的話會吃預設的15GB容量)，因為之前買HTC有送兩年的100GB google空間。 自動備份後可以刪除已備份的本機檔案來做空間管理，重點是可以建立相簿來讓其他使用者共同編輯，像是我跟老婆就建立了幾本孩子的相簿，來分別上傳我們各自拍的相片。 [APP]寶寶生活紀錄可以記錄每次餵奶時間，換尿布時間、擠奶次數及量，還有睡眠時間及圖表顯示等，可以觀察每日的飲食狀況，也可以幫助我知道我離上餐多久了！ 在找到這個APP前，原本還想說寫一支來做紀錄，但想想還好，因為要忙著餵奶哄睡我想寫好時他可能都三個月大了XD。 [APP]AndroMoney雖然本來就會由老婆做記帳，但孩子生出來後不免一直購買一些有的沒的，決定找一個可以同步來共同記帳的軟體，就選了這個評價不錯且開發很久仍有維護的APP。 [實體]JOIE-Litetrax豪華休旅推車 + JOIE提籃同品牌JOIE的推車跟提籃可以輕鬆合體，而且價格也滿親民的，全新的一組一萬內有找！提籃是在蝦皮買二手的，因為提籃大概用到3個月大就要換汽座了，推車則是買全新的，看到這台豪華休旅車就覺得滿棒的，除了本來就想買大輪三輪車(覺得推起來順、舒服勝過輕量化)外，他的造型也滿好看的，顏色也是屬於耐看耐髒的灰色系。因為自己的車很小台(March)，在看推車時特別注意尺寸，貨到時發現輪胎是可以快拆的，原本還想說要把後置物板拆掉，後來發現輪胎快拆後整台塞進去剛剛好的時候都快落淚了XD [實體]nac nac消毒鍋、調乳器消毒鍋是一定要有的啦！選擇蒸氣消毒是避免塑膠件被紫外線弄壞、這台也有可設定時間的烘乾功能，消毒完直接烘乾很方便。 調乳器則是可以當定溫熱水瓶使用的感覺，當孩子在哭的時候去把快煮壺弄滾然後泡奶在降溫實在是來不急啊！平常定溫放著，要泡時直接有剛好的溫度可以泡奶真的很方便！ [實體]德國BRITA濾水壺因為是母奶+配方奶混喂，除了熱水壺燒開外，也希望水質是有先過濾過的，所以買了這個。 還有滿多哩哩渣渣的，但主要比較大條暫時就上面幾項。 孩子出生後，仔細回頭看看自己這三年的過程，很多事情跟想像中的真的不同，還是要靠自己努力充實自己才能去做到理想中的自己啊..不希望相同的還是只有存摺進帳的數字而已了哈哈。 –最近在重看JavaScript，從觀念在開始學習一遍。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Baby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好久沒有這麼晚睡了..終於上線了~~]]></title>
    <url>%2F2017%2F01%2Fguas-blog-v1-online%2F</url>
    <content type="text"><![CDATA[原本預計年前要搞定的各種沒空弄到現在，眼看就要過年了只好熬夜拼了！終於把初版Blog放上來了～接著就按照自己的年度目標慢慢補足吧！ 去年底決定了今年的目標是要 每兩個月一定要寫篇程式相關的心得 每半年要看完一本書並記錄心得 之所以會有這樣的想法是因為碰到的東西越來愈多，每個都想hello world一下..但都是遇到問題就爬文，覺得有解的文章就存到書籤裡，但解決之後也不會再去看那些書籤了，等到下次發生問題又要再找一次 。 想著很多東西我自己也解釋不出個所以然，不如就把自己知道且還記得的寫起來，當作自己的資料庫來查，把腦子想的東西再用文字敘述一次也算是複習吧.. 看了一下各種部落格覺得綁手綁腳，不如自己寫一個吧，就產生了這樣的念頭 ，一直到現在第一版本上線花了快兩個月的下班跟假日時間 。 程式的部分選用了Laravel當作後端框架，前端則嘗試單純只用CSS寫RWD，很多東西再找時間慢慢調整，能如期在過年前上線真是太好了呢（雖然是農曆年前），網站大LOGO是勤勉，因為我一直想不到要拿什麼當logo..XD也是希望自己新的一年能繼續保持好奇心，加強自己吧！]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>BLOG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在AWS上用SpringBoot建立API]]></title>
    <url>%2F2017%2F01%2Fbuild-api-on-aws-use-spring-boot%2F</url>
    <content type="text"><![CDATA[紀錄去年底第一次接觸到AWS(Amazon Web Services)到在AWS上實作一個JSON格式的API，並在AWS上建立AP&amp;DB的方式 有了目的之後，經過初步查詢後理解基礎功能後的想法是： 開一台RDB(postgreSQL) 建立table塞資料 開一台EC2(ubuntu) 將EC2環境建置好 寫CODE(java) 放到EC2中啟動web server 後來根本就卡在4啊!!!!!!! 因為不熟命令列&amp;linux的環境，導致建置期各種問號我在EC2開好之後，使用putty連線，並爬文找了相關指令來下載java環境..等以及一直開鳥哥看怎麼操作vi瀏覽器，最後甚至還找了XRDP來連線看到桌面環境XD 後來我覺得應該要找更簡單輕鬆的方法來先實作出東西..不然依我的腦容量又不常用的東西很快就忘了，又繼續找更輕鬆的方法…就找到了Elastic Beanstalk! (#小叮噹圖) 這個只需我程式寫好，打包壓縮好上傳就會自己幫你長一台EC2出來，剛剛上述各種痛苦(之於菜鳥我而言)就不見了，變成一條簡單的路。 流程改為： 開一台RDB(postgreSQL) 建立table塞資料 寫CODE(java) 打包丟到AWS上 總算是把環境搞定後就開始找如何透過JAVA實作API的方法了，雖然對於使用JAVA的經驗很少，也是聽過Spring的，發現spring boot很類似php的感覺，只要把專案設定好就可以開始了，不用編輯pom.xml(對此實作而言)，也沒有spring的web.xml之類要設定，像是把xampp開好就可以自己生一個php file來實作的感覺了！ 最後是使用spring boot開發，並使用data jpa &amp; Rest Repositories來實作API，所以就來紀錄一下如何使用Spring Boot來實作簡易的API，並上傳至AWS。 以下正文開始 開發環境:windows7使用工具:sts 1. 開一台RDS 進到RDS介面建立資料庫(我選用postgreSql) 設定資料庫名稱、帳號密碼 安全群組的部分是選擇default 會花數分鐘時間建立RDS 2.建立Table 下載PGadminPostgreSQLe管理工具 設定PGadmin，建立連線 在RDS查詢連線資訊 範例如下 接著透過介面操作資料庫來建立一個USERS table 1234567CREATE TABLE USERS( id serial PRIMARY KEY, name varchar(20) NOT NULL, email varchar(50) NOT NULL, password varchar(50) NOT NULL, create_date date); INSERT三筆資料 1234INSERT INTO USERS(id, name, email, password, create_date) VALUES(1, 'testUser1', 'testUser1@email.com', '11111', CURRENT_TIMESTAMP),(2, 'testUser2', 'testUser2@email.com', '22222', CURRENT_TIMESTAMP),(3, 'testUser3', 'testUser3@email.com', '33333', CURRENT_TIMESTAMP) 3.寫CODE 下載Spring Tool Suite(STS) 建立專案(New-&gt;Other-&gt;Spring Starter Project) 我的設定如圖，選擇war檔是為了最終上傳至Elastic Beanstalk的格式 版本及使用項目如圖(JPA、PostgreSQL、Rest Repositories) 建立好之後，於src/main/java建立一個packge:com.example.models 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.example.models;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;//這裡可加上@Table(name = "")來指定table名稱//不加的話會自動以class name來找對應的表//可避開java底線(_)保留字的問題@Entity@Table(name = "users")public class User &#123; @Id @GeneratedValue private Long id; //@Column可指定欄位名稱@Column(name = "") //可避開java底線(_)保留字的問題 @Column(name = "name") private String name; @Column(name = "email") private String email; @Column(name = "password") private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 建立Packge:com.example.repostitories，並在底下建立UserRespository 1234567891011121314151617181920212223package com.example.repostitories;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.repository.PagingAndSortingRepository;import org.springframework.data.repository.query.Param;import org.springframework.data.rest.core.annotation.RepositoryRestResource;import org.springframework.data.rest.core.annotation.RestResource;import com.example.models.User;@RepositoryRestResource(collectionResourceRel = "Users", path="Users")public interface UserRepository extends PagingAndSortingRepository&lt;User, Long&gt; &#123; @RestResource(path = "find", rel = "find") Page&lt;User&gt; findByNameIgnoreCaseContaining(@Param("name") String name, Pageable pageable); /* * 方法findBy[column name]必須指定為欄位名稱，要注意的是要用domain建立的欄位名稱 * RepositoryRestResource的用途是指定一個路徑，對我來說是避免查詢名稱過長 * 因為以此例不指定的話會長這樣http://domain/users/findByNameIgnoreCaseContaining * 若查詢結果需分頁可改為Page&lt;Users&gt;並加上參數Pageable pageable, * 不然就是List&lt;User&gt; findByNameIgnoreCaseContaining(@Param("name") String name)就好了 */&#125; 設定application.properties設定連線資訊 12345678910111213#設定這個可指定連入api的路徑spring.data.rest.base-path=/apispring.jpa.database=POSTGRESQLspring.datasource.platform=postgresspring.jpa.show-sql=truespring.jpa.hibernate.ddl-auto=updatespring.database.driverClassName=org.postgresql.Driver#要加port號及所建立的資料庫名稱spring.datasource.url=jdbc:postgresql://domain:5432/databasespring.datasource.username=usernamespring.datasource.password=password#這裡改5000因為EB會用nginx來轉，port必須改為5000server.port = 5000 完成後的結構圖如下 進行Local端測試http://localhost:5000/api會獲得這個畫面↓ 自動生成了關於這個API的操作 進一步測試關於Users這個functionhttp://localhost:5000/api/Usershttp://localhost:5000/api/Users/search ####4.打包丟到AWS上面 專案右鍵選擇Meven Build Goals輸入package後run 找到產生的war檔(路徑會在consle顯示) 利用EB來上傳程式(平台選擇Tomcat) 系統會開始建置，完成後可見此程式外部連結 便可同在Local測試時一樣，只是把連結改成eb的http://yourAwsDomain/api/http://yourAwsDomain/api/Userhttp://yourAwsDomain/User/search 結束！從來沒想過會寫JAVA的心得囧..]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>AWS</tag>
        <tag>JAVA</tag>
        <tag>API</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紀錄Mac OS安裝laravel開發環境(composer + valet + mysql)]]></title>
    <url>%2F2017%2F01%2Fmac-install-laravel-composer-valet-mysql%2F</url>
    <content type="text"><![CDATA[拿到mac後最期待的事情就是命令列了，之前爬文看到各種指令安裝環境神之快，初次體並記錄安裝Laravel環境的過程(使用osx專屬的valet) 依序安裝如下: HomeBrew Composer PHP &amp; php-version(版本控制) MySQL Valet phpMyAdmin 安裝HomeBrew輸入/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install) 若已安裝HomeBrew則可先進行更新，輸入brew update 使用brew安裝composer輸入brew install composer安裝完後輸入composer –version測試 使用brew安裝php安裝php7輸入brew install php70，可輸入php –v驗證版本可安裝php-version來切換輸入brew install php-versionz輸入source $(brew --prefix php-version)/php-version.sh &amp;&amp; php-version 5就可透過php-version來查詢所安裝的php版本，再透過php-version [版本號]來切換 我的系統為macOS Sierra 10.12.2，預設已有php5.6.27 使用brew安裝mysql輸入brew install mysql，安裝完畢後輸入mysql.server start來執行 預設是沒有密碼的，可透過mysql_secure_installation來設置密碼 透過composer來安裝valet輸入composer globalrequire laravel/valet接著輸入valet install來安裝valet跟dnsmasq 若有發生valet install失敗，檢視/.composerf看看輸入export PATH=&quot;$PATH:~/.composer/vendor/bin&quot;執行source ~/.bash_profile再透過echo $PATH確認已加入到path中 透過valet設置專案連結找個地方放置你的專案文件，例如我是建立在Dcoument/php-workspaceValet可以透過park及link來設定站點，並透過share指令分享站點 park用法切換到你的專案目錄後輸入valet park接著你底下的所有laravel目錄都會成為一個web的站點，例如php-workspace中有blog及shop這兩個目錄，在瀏覽器輸入blog.dev及shop.dev即可連結！ link用法Park是針對整個專案目錄底下做設置，link則是對單一目錄做命名及連結切換至想設定的專案資料夾中輸入valet link [app-name]便完成設置例如輸入的是valet link blog，則瀏覽器輸入blog.dev就會連到剛才設置的目錄中檢視所有的link透過valet links，而valet unlink app-name則可用來移除link share用法切換目錄至你要分享出去的專案資料夾中，輸入valet share會產生一段網址並自動複製起來，便可透過瀏覽器直接連結到這個專案中！結束則在teminal介面按下CTAL+C即可，超簡易的分享站點方式！！ 安裝phpMyAdmin到官網中下載後解壓縮，放到你的專案目錄並使用park或link來設置 例如我放在Documents/php-workspace/phpMyAdmin中前面已經在php-workspace設定過valet park了所以只要放進這個目錄的資料夾都是一個web根目錄放進來後只需要在瀏覽器輸入phpMyAdmin.dev就可以了]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac初體驗]]></title>
    <url>%2F2017%2F01%2Ffirst-use-mac%2F</url>
    <content type="text"><![CDATA[去年（雖然也才剛過）決定今年一定要買台Mac來用OSX練習開發，以前公司只有稍微用來build Xcode專案測試過，原本在想著要買mbpr，但那價錢太殘酷我不敢看，且也沒用過不確定自己是否能習慣這樣的環境，不敢花下去．． 有次跟同事閒聊到想買Mac的這件事，剛好他有台Mac Mini 2012 割愛賣給我（還升級好了16G ram &amp; SSD）就把家裡那台跟了我7年的PC挪去電視後面當檔案伺服器+智慧電視用啦。 目前使用快一週，作為一個鄉下人第一次使用MacOS的心得如下：優點： 各種美麗啊真棒！（如果我PC還沒升級Win10的話這個感動會再加倍) 切換桌面這件事情對我來說很方便，不用在小畫面擠一堆東西了 很鄉下的初次使用各種指令來安裝東西，覺得各種神奇(以laravel來說, windows若非使用wagon則安裝步驟神之難, OSX就HomeBrew一直install就好了） 缺點： 應該是說我自己不習慣，注音模式下打出的英文及數字都會變大寫格式讓我很不爽 滑鼠滾輪的習慣(跟windows相反，不過用一陣子後現在覺得這樣比較”自然”) 測網頁時字體要在遠端回PC確認是不是假象（Mac預設字體太美的會忘記新細明體的假象） 後來自己額外買的東西： Mini DisplayPort轉DVI的接頭：因為我的Dell螢幕沒有HDMI介面 羅技M557藍牙滑鼠：剛好原本的雷蛇滾輪壞了，看到PTT有推就買了自訂功能鍵滿不錯的（我是設定中間那顆Mission Control，滾輪左右為切換桌布） Mac Keyboard(有線數字鍵版)：為了那幾顆Mac專屬的鍵位&amp;好美 要說真正的心得的話就是 相見恨晚啊啊啊！！]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
</search>
